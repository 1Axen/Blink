{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"Blink <p>An IDL compiler written in Luau for ROBLOX buffer networking</p>"},{"location":"#performance","title":"Performance","text":"<p>Blink aims to generate the most performant and bandwidth-efficient code for your specific experience, but what does this mean?  </p> <p>It means lower bandwidth usage directly resulting in lower ping* experienced by players and secondly, it means lower CPU usage compared to more generalized networking solutions.</p> <p>* In comparasion to standard ROBLOX networking, this may not always be the case but should never result in increased ping times.</p> <p>Benchmarks are available here here.</p>"},{"location":"#security","title":"Security","text":"<p>Blink does two things to combat bad actors: 1. Data sent by clients will be validated on the receiving side before  reaching any critical game code. 2. As a result of the compression done by Blink it becomes significantly harder to snoop on your game's network traffic. Long gone are the days of skids using RemoteSpy to snoop on your game's traffic.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>Head over to the installation page to get started with Blink.</p>"},{"location":"#credits","title":"Credits","text":"<p>Credits to Zap for the range and array syntax Credits to ArvidSilverlock for the float16 implementation Studio plugin auto completion icons are sourced from Microsoft and are under the CC BY 4.0 license. Speed icons created by alkhalifi design - Flaticon</p>"},{"location":"Benchmarks/","title":"Benchmarks","text":""},{"location":"Benchmarks/#methodology","title":"Methodology","text":"<p>Benchmarks are done by firing the event 1000 times per frame with the same data every frame for 10 seconds. </p> <p>Source code can be found here here. Data used for benchmarks can be found here.  Defenition files used for benchmarks can be found here.  </p>"},{"location":"Benchmarks/#results","title":"Results","text":"<p><code>P[NUMBER]</code> = [NUMBER] Percentile The tables below were automatically generated by this script. Last Updated 2024-05-06 18:20:25 UTC </p>"},{"location":"Benchmarks/#tool-versions","title":"Tool Versions","text":"<p>blink: <code>v0.11.1</code> zap: <code>v0.6.3</code> bytenet: <code>v0.4.3</code> </p>"},{"location":"Benchmarks/#computer-specs","title":"Computer Specs","text":"<p>Processor: <code>Intel(R) Core(TM) i5-10400F CPU @ 2.90GHz</code> Memory #1: <code>8GB 2400</code> Memory #2: <code>8GB 2400</code> </p>"},{"location":"Benchmarks/#entities","title":"Entities","text":"Tool (FPS) Median P0 P80 P90 P95 P100 Loss (%) roblox 15.00 15.00 15.00 15.00 15.00 15.00 0% bytenet 22.00 24.00 22.00 22.00 22.00 21.00 0% zap 21.00 24.00 20.00 20.00 20.00 19.00 0% blink 25.00 26.00 24.00 24.00 24.00 24.00 0% Tool (Kbps) Median P0 P80 P90 P95 P100 Loss (%) roblox 489885.03 489885.03 489885.03 489885.03 489885.03 752780.69 0% bytenet 41.76 18.59 43.23 43.36 43.36 45.15 0% zap 42.17 18.49 43.90 44.28 44.28 44.41 0% blink 41.61 19.80 43.13 43.40 43.40 43.92 0%"},{"location":"Benchmarks/#booleans","title":"Booleans","text":"Tool (FPS) Median P0 P80 P90 P95 P100 Loss (%) roblox 16.00 17.00 16.00 15.00 15.00 15.00 0% bytenet 21.00 22.00 20.00 20.00 20.00 20.00 0% zap 34.00 34.00 33.00 33.00 33.00 33.00 0% blink 60.00 60.00 60.00 60.00 60.00 60.00 0% Tool (Kbps) Median P0 P80 P90 P95 P100 Loss (%) roblox 212987.14 135647.37 384906.31 713720.18 713720.18 1163118.40 0% bytenet 8.97 4.10 9.11 9.25 9.25 9.41 0% zap 8.68 4.78 8.89 8.93 8.93 8.97 0% blink 8.48 6.23 8.52 8.57 8.57 8.58 0%"},{"location":"Getting-Started/","title":"Getting Started","text":""},{"location":"Getting-Started/#write-your-first-network-description","title":"Write your first network description","text":"<p>If you're looking for an example you can check out the source file used for testing. For a guide on the syntax of Blink head over to Writing network descriptions.</p>"},{"location":"Getting-Started/#generating-code","title":"Generating code","text":"<p>Blink currently only supports code generation through CLI. To generate output code run the following command in the directory in which you installed Blink: <pre><code>blink [INPUT]\n</code></pre></p>"},{"location":"Getting-Started/#using-the-generated-code","title":"Using the generated code","text":"<p>When requiring the code generated it will return a table which contains all defined events &amp; functions, you can use this table to fire/invoke and listen to events/functions. <pre><code>local Blink = require(PATH_TO_MODULE)\n\n--&gt; Firing events\nBlink.Example.Fire(1)\nBlink.Example.FireAll(1)\nBlink.Example.FireList(List, 1)\nBlink.Example.FireExcept(Player, 1)\n\n--&gt; Listening to events\nBlink.AnotherExample.Listen(function(...)\n    print(...)\nend)\n</code></pre></p>"},{"location":"Installation/","title":"Installation","text":""},{"location":"Installation/#from-aftman","title":"From Aftman","text":"<p>Note</p> <p>The aftman version of Blink currently only supports windows x86 and x64.</p> <pre><code>aftman add 1Axen/Blink\n</code></pre>"},{"location":"Installation/#from-github-releases","title":"From GitHub Releases","text":"<p>Download the standalone executable from Github Releases.</p>"},{"location":"Installation/#from-bytecode","title":"From Bytecode","text":"<p>Alternative you can run blink from bytecode using line. You can download the packaged bytecode from Github Releases.</p>"},{"location":"Installation/#studio-plugin","title":"Studio Plugin","text":"<p>Blink offers a companion studio plugin which allows you to write and generate files within Studio without the need for external tooling. You can download the latest plugin from Github Releases. For more information on how to use it head over to Studio Plugin.</p>"},{"location":"Installation/#installing-lune","title":"Installing lune","text":"<p>Blink uses lune as it's runtime enviornment, you can install lune using aftman: <pre><code>aftman add filiptibell/lune\n</code></pre></p>"},{"location":"Installation/#running-bytecode","title":"Running bytecode","text":"<p>Open the directory in which you unzipped the bytecode and run the following command: <pre><code>lune init [INPUT]\n</code></pre></p>"},{"location":"Installation/#plugin-marketplace","title":"Plugin Marketplace","text":"<p>Coming soon!</p>"},{"location":"Plugin/","title":"Studio Plugin","text":""},{"location":"Plugin/#navigating","title":"$ Navigating","text":"<p>After installing the plugin locate it within your plugin tab in Studio.</p> <p>Note</p> <p>After opening the plugin you will be prompted to give it access to inject scripts, the plugin needs this in order to generate the output files.  </p> <p></p>"},{"location":"Plugin/#menu","title":"Menu","text":"<p>Tip</p> <p>You can open the side menu using the sandwich button on the left hand side.</p> <p> </p> <p>Within the menu you can manage your network description files.  </p>"},{"location":"Plugin/#saving","title":"Saving","text":"<p>To save a network description simply press the save button at the bottom of the side menu.  This will prompt you to save whatever is currently in the editor.</p> <p>Tip</p> <p>You can save to already existing files by simply inputting their name</p> <p> </p>"},{"location":"Plugin/#generating","title":"Generating","text":"<p>To generate your networking modules simply press the \"Generate\" button on your desired file. This will open a prompt asking you to select your desired output destination within the game explorer.  </p> <p> </p> <p>Once you've selected your desired output destination simply press \"Generate\" and your files will be ready.  </p> <p> </p> <p>If no issues arise Blink will generate the following Folder containing your networking modules:  </p> <p> </p>"},{"location":"Plugin/#editor","title":"Editor","text":"<p>Tip</p> <p>Invalid syntax will be highlighted in red or underlined. </p>"},{"location":"Plugin/#errors","title":"Errors","text":"<p>Upon generating output files, Blink will parse the source contents and inform you of any errors within your files that are blocking generation.  </p> <p></p>"},{"location":"Using/","title":"Using","text":""},{"location":"Using/#options","title":"Options","text":"<p>Options go at the top of a source file and are used to configure the output of Blink. <pre><code>option [OPTION] = [VALUE]\n</code></pre></p>"},{"location":"Using/#casing","title":"<code>Casing</code>","text":"<p>Default: <code>Pascal</code> Options: <code>Pascal</code>, <code>Camel</code>, <code>Snake</code> Controls the casing with which event/function methods generate. <pre><code>option Casing = Camel\n</code></pre></p>"},{"location":"Using/#serveroutput-clientoutput-typesoutput","title":"<code>ServerOutput</code>, <code>ClientOutput</code>, <code>TypesOutput</code>","text":"<p>These options allow you to specify where Blink will generate files. <pre><code>option TypesOutput = \"../Network/Types.luau\"\noption ServerOutput = \"../Network/Server.luau\"\noption ClientOutput = \"../Network/Client.luau\"\n</code></pre></p>"},{"location":"Using/#futurelibrary-and-promiselibrary","title":"<code>FutureLibrary</code> and <code>PromiseLibrary</code>","text":"<p>In order to use future and promise yield types with functions a path to each library used must be specified <pre><code>option FutureLibrary = \"ReplicatedStorage.Packages.Future\"\noption PromiseLibrary = \"ReplicatedStorage.Packages.Promise\"\n</code></pre></p>"},{"location":"Using/#writevalidations","title":"<code>WriteValidations</code>","text":"<p>Default: <code>false</code> Controls if Blink will check types when writing them (firing an event/invoking a function). Helpful for debugging and during development, but it might result in degraded performance. It is encouraged you disable this option in production.</p> <p>Tip</p> <p>Blink only checks for builtin primitives. For example if a number was passed. More complicated types like structs, maps and enums cannot be validated.</p>"},{"location":"Using/#manualreplication","title":"<code>ManualReplication</code>","text":"<p>Default: <code>false</code> Controls if Blink will replicate events and functions automatically at the end of every frame. When set to <code>true</code> automatic replication will be disabled and a <code>StepReplication</code> function will be exposed instead.</p>"},{"location":"Using/#primitives","title":"Primitives","text":"<p>You can define a primitive using the <code>type</code> keyword Blink supports the following primitives:  </p> Name Size (Bytes) Supports ranges Minimum Maximum Components u8 1 Byte Yes 0 255 No u16 2 Bytes Yes 0 65,535 No u32 4 Bytes Yes 0 4,294,967,295 No i8 1 Byte Yes -128 127 No i16 2 Bytes Yes -32,768 32,767 No i32 4 Bytes Yes -2,147,483,648 2,147,483,647 No f16 2 Bytes Yes -65504 65504 No f32 4 Bytes Yes \u221216777216 16777216 No f64 8 Bytes Yes -2^53 2^53 No vector 12 Bytes Yes (Magnitude) N/A N/A Yes (1) buffer N/A Yes (buffer.len) N/A 65,535 Bytes No string N/A Yes (string.len) N/A 65,535 Bytes No boolean 1 Byte No N/A N/A No CFrame 24 Bytes No N/A N/A Yes (2) Color3 12 Bytes No N/A N/A No Instance 4 Bytes No N/A N/A No unknown N/A No N/A N/A No"},{"location":"Using/#attributes","title":"Attributes","text":"<p>A type can be marked optional by appending <code>?</code> at the end.</p> <p>Arrays can be defined by appending <code>[SIZE]</code> or <code>[[MIN]..[MAX]]</code> after the type declaration.  </p> <p>Primitives can be constrained to ranges by writing <code>([MIN]..[MAX])</code> after the primitive type. Ranges are inclusive.  </p> <p>Components can be specified using the angled brackets <code>&lt;&gt;</code>, they allow you to specify what numerical type (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>) to use for <code>vector</code> and <code>CFrame</code> axes. For example <code>vector&lt;i16&gt;</code> will define a vector that represents its axes using <code>i16</code>. CFrames take two components <code>CFrame&lt;f32, f32&gt;</code>, one representing position and one representing rotation in order.</p> <p>Warning</p> <p>Using non float types for CFrame will result in the rotation being reset to 0.</p> <pre><code>type Simple = u8\ntype Optional = u8?\ntype Array = u8[1]\ntype Range = u8[0..100]\ntype VectorInt16 = vector&lt;int16&gt;\ntype Orientation = CFrame&lt;int16, f16&gt;\nmap Players = {[u8]: Instance(Player)}[0..255]\nenum States = (A, B, C, D)[0..255]\nstruct Dictionary {\n    Field: u8\n}[0..255]\n</code></pre>"},{"location":"Using/#enums","title":"Enums","text":"<p>You can define enums using the <code>enum</code> keyword. Blink has two type of enums, unit and tagged enums.</p>"},{"location":"Using/#unit-enums","title":"Unit Enums","text":"<p>Unit enums represent a set of possible values. For example, a unit enum representing the state of a car engine: <pre><code>enum State = { Starting, Started, Stopping, Stopped }\n</code></pre></p>"},{"location":"Using/#tagged-enums","title":"Tagged Enums","text":"<p>Tagged enums represent a set of possible variants with some data attached to each. They are defined using a string which represents the tag field name. Each variant is defined by a tag, followed by a struct. <pre><code>struct Vector2 {\n    X: u16,\n    Y: u16\n}\n\nenum Buttons = {Left, Right, Middle}\nenum MouseEvent = \"Type\" {\n    Move {\n        Delta: Vector2,\n        Position: Vector2,\n    },\n    Drag {\n        Delta: Vector2,\n        Position: Vector2\n    },\n    Click {\n        Button: Buttons,\n        Position: Vector2\n    },\n}\n</code></pre></p>"},{"location":"Using/#structs","title":"Structs","text":"<p>You can define structs using the <code>struct</code> keyword Structs can also hold structs within: <pre><code>struct Entity {\n    Identifier: u8,\n    Health: u8(0..100),\n    State: ( Dead, Alive )?,\n    Direction: vector(0..1),\n    Substruct: struct {\n        Empty: u8[0],\n        Complex: u8[1..12],\n        Vector: UnitVector,\n    }?\n}\n</code></pre></p>"},{"location":"Using/#generics","title":"Generics","text":"<p>Structs, tagged enums and maps support the use of generic type parameters, a generic is simply a type which allows you to slot in any other type, generics can be very handy in reducing repetition. <pre><code>struct Packet&lt;T&gt; {\n    Sequence: u16,\n    Ack: u16,\n    Data: T\n}\n\nstruct Entity {\n    Identifier: u8,\n    Health: u8(0..100),\n    Angle: u16,\n    Position: vector\n}\n\nstruct Command {\n    X: u8,\n    Y: u8,\n    Z: u8,\n    -- ...\n}\n\nevent Snapshot {\n    From: Server,\n    Type: Unreliable,\n    Call: SingleSync,\n    Data: Packet&lt;Entity[]&gt;\n}\n\nevent Command {\n    From: Server,\n    Type: Unreliable,\n    Call: SingleSync,\n    Data: Packet&lt;Command&gt;\n}\n</code></pre> In the code above we have a simple packet transmission protocol which contains the current packets identifier (Sequence), the last recieved packet (Ack) and a generic data field. Instead of repeating the contents of <code>Packet</code> everytime we need to send something over the wire we can take advantage of generics to automatically fill the <code>Data</code> field with whatever we need to transmit.</p>"},{"location":"Using/#maps","title":"Maps","text":"<p>You can define maps using the <code>map</code> keyword   </p> <p>[!NOTE] Maps cannot currently have maps as keys or values. You also cannot have optional keys or values as there is no way to represent those in Luau. <pre><code>map Example = {[string]: u8}\n</code></pre></p>"},{"location":"Using/#instances","title":"Instances","text":"<p>Instances are another type of Primitive and as such they can be defined using the <code>type</code> keyword <pre><code>type Example = Instance\ntype Example = Instance(ClassName) -- You can also specify instance class\n</code></pre></p> <p>Warning</p> <p>If a non optional instance results in nil on the recieving side it will result in an error, this may be caused by various things like streaming, players leaving etc. In order to get around this you must mark instances as optional.</p>"},{"location":"Using/#tuples","title":"Tuples","text":"<p>Tuples can be defined using brackets <code>()</code>. Tuples can only be defined within the data field of an event/function. <pre><code>event Example {\n    From: Server,\n    Type: Reliable,\n    Call: SingleSync,\n    Data: (u8, u16?, Instance, Instance?, u8[8])\n}\n</code></pre></p>"},{"location":"Using/#events","title":"Events","text":"<p>You can define events using the <code>event</code> keyword Events have 4 fields: <code>From</code> - <code>Client</code> or <code>Server</code> <code>Type</code> - <code>Reliable</code> or <code>Unreliable</code> <code>Call</code> - <code>SingleSync</code> or <code>SingleAsync</code> <code>Data</code> - Can hold either a type definition or a reference to an already defined type <pre><code>event Simple {\n    From: Client,\n    Type: Unreliable,\n    Call: SingleSync,\n    Data: u8\n}\n\nevent Reference {\n    From: Client,\n    Type: Unreliable,\n    Call: SingleSync,\n    Data: Entity\n}\n\nevent Complex {\n    From: Client,\n    Type: Unreliable,\n    Call: SingleSync,\n    Data: struct {\n        Field = u8\n    }\n}\n</code></pre></p>"},{"location":"Using/#functions","title":"Functions","text":"<p>You can define functions using the <code>function</code> keyword Functions have 3 fields: <code>Yield</code> - <code>Coroutine</code> or <code>Future</code> or <code>Promise</code>  Deifnes what library will be used to handle invocations <code>Data</code> - Can hold either a type definition or a reference to an already defined type <code>Return</code> - Can hold either a type definition or a reference to an already defined type  <pre><code>function Example {\n    Yield: Coroutine,\n    Data: u8,\n    Return: u8\n}\n\nfunction ExampleFuture {\n    Yield: Future,\n    Data: u8,\n    Return: u8\n}\n\nfunction ExamplePromise {\n    Yield: Promise,\n    Data: u8,\n    Return: u8\n}\n</code></pre></p>"},{"location":"Using/#scopes-namespaces","title":"Scopes (Namespaces)","text":"<p>You can define a scope (namespace) using the <code>scope</code> keyword Scopes allow you to group similiar types together for further organization  </p> <p>Defining scopes: <pre><code>scope ExampleScope {\n    type InScopeType = u8\n    event InScopeEvent {\n        From: Server,\n        Type: Reliable,\n        Call: SingleSync,\n        Data: u8\n    }\n}\n\nstruct Example {\n    Reference = ExampleScope.InScopeType\n}\n</code></pre></p> <p>Scopes automatically inherit any declarations made within their parent scopes (including main) <pre><code>type Example = u8\nscope ExampleScope {\n    type TypeInScope = u8\n    scope ExampleNestedScope {\n        -- Example is taken from the main (global) scope\n        -- TypeInScope is taken from the parent scope (ExampleScope)\n        map ExampleMap = {[Example]: TypeInScope}\n    }\n}\n</code></pre></p> <p>Using scopes in code: <pre><code>local Blink = require(PATH_TO_BLINK)\nBlink.ExampleScope.InScopeEvent.FireAll(0)\n\nlocal Number: Blink.ExampleScope_InScopeEvent = 0\n</code></pre></p>"},{"location":"Using/#imports","title":"Imports","text":"<p>Warning</p> <p>Imports are not currently supported when compiling using the Studio Plugin.</p> <p>Blink allows you to use multiple definition files through importing. Imports will pull all declarations (events, functions, scopes and types) from the target file and load them into the importing scope as a new scope using either the file name or a user provided name through the <code>as</code> keyword. <pre><code>import \"../path/File.blink\" --&gt; Imports as a new scope \"File\"\ntype a = File.b\n</code></pre> <pre><code>import \"../path/File.blink\" as Something --&gt; Imports as a new scope \"Something\"\ntype a = Something.b\n</code></pre> <pre><code>scope MyScope {\n    --&gt; Imports a new scope \"Something\" into \"MyScope\"\n    import \"../path/File.blink\" as Something\n}\ntype a = MyScope.Something.b\n</code></pre></p>"},{"location":"Using/#limitations","title":"Limitations","text":""},{"location":"Using/#referencing-types","title":"Referencing types","text":"<p>A type must be defined earlier in the source for it to be referenceable, you cannot reference a type before it has been defined. <pre><code>struct Invalid {\n    Field: Number\n}\ntype Number = u8\n</code></pre> <pre><code>[ERROR]\n    |\n002 |     Field = Number\n    |             ^^^^^^ Unknown type referenced.\n</code></pre></p>"},{"location":"Using/#keywords","title":"Keywords","text":"<p>You cannot use any keywords as \"Identifiers\". <pre><code>type struct = {}\n</code></pre> <pre><code>[ERROR]\n    |\n001 | type struct = {\n    |      ^^^^^^ Unexpected token: \"Keyword\", expected: \"Identifier\".\n</code></pre></p>"}]}