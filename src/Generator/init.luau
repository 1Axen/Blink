--!native
--!optimize 2
--!strict

local Blocks = require("./Blocks")
local Parser = require("../Parser")
local Builder = require("../Modules/Builder")
local Prefabs = require("./Prefabs")
local Settings = require("../Settings")

local Sources = {
	Base = require("../Templates/Base"),
	Client = string.split(require("../Templates/Client"), "-- SPLIT --"),
	Server = string.split(require("../Templates/Server"), "-- SPLIT --"),
}

local DIRECTIVES = "--!strict\n--!native\n--!optimize 2\n--!nolint LocalShadow\n--#selene: allow(shadowing)\n"
local VERSION_HEADER = `-- File generated by Blink v{_G.VERSION or "0.0.0"} (https://github.com/1Axen/Blink)\n-- This file is not meant to be edited\n\n`

local EVENT_BODY = [[RecieveCursor = 0
RecieveBuffer = Buffer
RecieveInstances = Instances
RecieveInstanceCursor = 0
local Size = buffer.len(RecieveBuffer)]]

local RELIABLE_BODY = {
	Header = "local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances",
	Body = [[Load(PlayersMap[Player])
local Position = Allocate(Size)
buffer.copy(SendBuffer, Position, Buffer, 0, Size)
table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
PlayersMap[Player] = Save()]]
}

local UNRELIABLE_BODY = [[local Buffer = buffer.create(SendCursor)
buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)]]

local DEBUUG_GLOBALS = [[local og_typeof = typeof
local typeof = function(a: any)
    if type(a) == "table" then 
        return a.__typeof or "table" 
    end
    return og_typeof(a)
end
local task = require("@lune/task")
local game = _G.%s.game
]]

local PRIMITIVES = Settings.Primtives

type Type = Parser.TypeDeclaration

local Scope: string?
local Context: string;
local Casing: Settings.Cases;
local Events: Builder.Builder;
local UserTypes: Builder.Builder;
local LuauTypes: Builder.Builder;
local Reliables: Blocks.Block;
local Unreliables: Blocks.Block;
local Return: Builder.Builder;
local Options: Parser.Options;

local Generators = {}
local Declarations = {}

local Channels: { [string]: { Count: number, Listening: boolean } } = {
	Reliable = { Count = 0, Listening = false },
	Unreliable = { Count = 0, Listening = false },
}

local Types = Prefabs.Types
local Primitives = Prefabs.Primitives
local Structures = Prefabs.Structures

--> Utility functions

local function GetTypesPath(Identifier: string, Scope: string?, Write: boolean): string
	return `Types.{Scope and `{Scope}.` or ""}{Write and "Write" or "Read"}{Identifier}`
end

local function GetExportName(Identifier: string): string
	return `{Scope and `{Scope}_` or ""}{Identifier}`
end

local function GenerateEnumLiterals(Enums: { string }): string
	local Literal = ""
	for Index, EnumItem in Enums do
		Literal ..= `"{EnumItem}"{Index < #Enums and " | " or ""}`
	end
	return Literal
end

--> Declaration functions

function Declarations.Primitive(Declaration: Parser.PrimitiveDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Tokens = Declaration.Tokens
	local Primitive = Tokens.Primitive.Value
    local Generator = Primitives[Primitive]
    Generator.Generate(Declaration, Variable, Read, Write)
end

function Declarations.Enum(Declaration: Parser.EnumDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Enums = Value.Values
	local Literal = GenerateEnumLiterals(Enums)
	Literal = string.gsub(Literal, "|", "or")

	--> Read body
	Types.u8.Read(`local Index`, Read)
	Read = Read:Compare("Index", "0", "Equals")
		for Index, EnumItem in Enums do
			if Index > 1 then
				Read = Read:Branch("Conditional", "Index", `{Index - 1}`, "Equals")
			end

			Read:Line(`{Variable} = "{EnumItem}"`)
		end
	Read:Branch("Default")
		:Line(`error(\`Unexpected enum: \{Index\}\`)`)
	:End()

	--> Write body
	local Allocation = Write:Allocate(1)
		for Index, EnumItem in Enums do
			if Index == 1 then
				Write = Write:Compare(Variable, `"{EnumItem}"`, "Equals")
			else
				Write = Write:Branch("Conditional", Variable, `"{EnumItem}"`, "Equals")
			end

			Write:Line(`buffer.writeu8(SendBuffer, {Allocation}, {Index - 1})`)
		end
	Write:Branch("Default")
		:Line(`error(\`Unexpected enum: \{{Variable}\}, expectd one of {Literal}.\`)`)
	:End()
end

function Declarations.Map(Declaration: Parser.MapDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local MapValue = Declaration.Value
	local Key = MapValue.Key
	local Value = MapValue.Value

	local KeyType = Generators.LuauType(Key :: Type)
	local ValueType = Generators.LuauType(Value :: Type)

	Read:Line(`{Variable} = \{\}`)
	Write:Line("local Elements = 0")
	Types.u16.Read(`local Elements`, Read)

	local ReadLoop = Read:Loop("_ = 1", "Elements")
	local WriteLoop = Write:Iterator("Key", "Element", Variable)

	ReadLoop:Line(`local Key: {KeyType}, Element: {ValueType};`)
	WriteLoop:Line("Elements += 1")
	Generators.UserType(Key :: Type, ReadLoop, WriteLoop, "Key")
	Generators.UserType(Value :: Type, ReadLoop, WriteLoop, "Element")
	ReadLoop:Line(`{Variable}[Key] = Element`)

	WriteLoop:End()
	ReadLoop:End()

	Write:Line(`buffer.writeu16(SendBuffer, {Write:Allocate(2)}, Elements)`)
end

function Declarations.Struct(Declaration: Parser.StructDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	Read:Line(`{Variable} = \{\} :: any`)

	for _, Field in Value.Values do
		local FieldValue = Field.Value
		local Identifier = FieldValue.Identifier
		local FieldVariable = `{Variable}.{Identifier}`
		Generators.UserType(Field :: Type, Read, Write, FieldVariable)
	end
end

function Declarations.Tuple(Declaration: Parser.TupleDeclaration, Read: Blocks.Block, Write: Blocks.Block)
	for Index, Value in Declaration.Value.Values do
		local Variable = `Value{Index}`
		Generators.UserType(Value :: Type, Read, Write, Variable)
	end
end

function Declarations.Reference(Declaration: Parser.ReferenceDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
    local Value = Declaration.Value
	local Scope = Value.Scope
	local Reference = Value.Declaration
	local Identifier = Reference.Value.Identifier

	--[[
	local ReadPath = GetTypesPath(Identifier, Scope, false)
	local WritePath = GetTypesPath(Identifier, Scope, true)

	Read:Line(`{Variable} = {ReadPath}()`)
	Write:Line(`{WritePath}({Variable})`)]]

	--> Inline reference
	Generators.UserType(Reference, Read, Write, Variable)
end

function Declarations.Event(Declaration: Parser.EventDeclaration)
	local Value = Declaration.Value

	local Identifier = `EVENT_{Value.Identifier}`
	local Reliability = Value.Type

	local IsReliable = (Reliability == "Reliable")
	local IsUnreliable = (Reliability == "Unreliable")

	local Block = IsUnreliable and Unreliables or Reliables
	local Channel = IsUnreliable and Channels.Unreliable or Channels.Reliable

	local Index = Channel.Count
	local Queue = `Queue.{Reliability}[{Index}]`
	local Connection = `Events.{Reliability}[{Index}]`

	--> Data body
	local _, Values, _, Arguments = Generators.LuauType(Value.Data :: Type, true)
	local Read, Write = Generators.Event(Value.Data :: Type, Index, Identifier)
	UserTypes.PushMultiline(Read, 1, 0, false)
	UserTypes.PushMultiline(Write, 1, 0, false)

	--> Return body
	local Body = Builder.new()
	local Indent = Scope and 2 or 1
	local WriteEvent = `{GetTypesPath(Identifier, Scope, true)}({Arguments})`
	Body.Push(`{Value.Identifier} = \{`, 1, Indent)

	if Value.From ~= Context then
		--> Create queue and event branch
		Events.Push(`{Queue} = table.create(256)`)
		Block = (Channel.Listening == false)
			and Block:Compare("Index", Index, "Equals")
			or Block:Branch("Conditional", "Index", Index, "Equals")
	
		--> Update event block to branch block
		if IsUnreliable then
			Unreliables = Block
		else
			Reliables = Block
		end
		
		--> Update channel status
		Channel.Listening = true

		--> Event recieve body
		local Listener: Blocks.Block;
		local ContextArguments = `Listener: ({Context == "Server" and "Player: Player, " or ""}{Values}) -> ()`
		local ListenerArguments = `{Context == "Server" and "Player, " or ""}{Arguments}`
		local CallListenerFunction = Value.Call == "SingleSync" and `{Connection}({ListenerArguments})` or `task.spawn({Connection}, {ListenerArguments})`

		Block:Line(`local {Values} = {GetTypesPath(Identifier, Scope, false)}()`)

		if IsReliable then
			Block:Compare(Connection, "nil", "Not")
				:Line(CallListenerFunction)
			:Branch("Default")
				:Compare(`#{Queue}`, "256", "Greater")
					:Line(`warn("[Blink]: Event queue of \\"{Value.Identifier}\\" exceeded 256, did you forget to implement a listener?")`)
				:End()
				:Line(`table.insert({Queue}, \{{ListenerArguments}\} :: \{any\})`)
			:End()

			local Disconnect = Blocks.Function("", "", "()")
				:Line(`{Queue} = \{\}`)
				:Line(`{Connection} = nil`)
			:End()

			local FlushQueue = Blocks.Function("", "", "()")
				:Line(`local EventQueue = {Queue} or \{\}`)
				:Line(`{Queue} = nil`)
				:Iterator("Index", "Arguments", "EventQueue")
					:Line(Value.Call == "SingleSync" and `Listener(table.unpack(Arguments))` or `task.spawn(Listener, table.unpack(Arguments))`)
				:End()
			:End()

			Listener = Blocks.Function(Casing.On, ContextArguments, `() -> ()`, true)
				:Line(`{Connection} = Listener`)
				:Multiline(`task.spawn({FlushQueue:Unwrap()})`, 1)
				:Multiline(`return {Disconnect:Unwrap()}`, 1)
			:End()
		else
			Block:Compare(Connection, "nil", "Not")
				:Line(CallListenerFunction)
			:End()

			local Disconnect = Blocks.Function("", "", "()")
				:Line(`{Connection} = nil`)
			:End()

			Listener = Blocks.Function(Casing.On, ContextArguments, `() -> ()`, true)
				:Line(`{Connection} = Listener`)
				:Multiline(`return {Disconnect:Unwrap()}`, 1)
			:End()
		end

		Body.PushMultiline(Listener:Unwrap(), 0, Indent + 1)
	elseif Context == "Client" then
		local Fire = Blocks.Function(Casing.Fire, Values, "()", true)
			if IsReliable then
				Fire:Line(WriteEvent)
			else
				Fire:Line(`local Previous = Save()`)
				Fire:Line(`Load()`)
				Fire:Line(WriteEvent)
				Fire:Line("local Buffer = buffer.create(SendCursor)")
				Fire:Line("buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)")
				Fire:Line("Unreliable:FireServer(Buffer, SendInstances)")
				Fire:Line("Load(Previous)")
			end
		Fire:End()
		Body.PushMultiline(Fire:Unwrap(), 0, Indent + 1)
	else
		local Fire = Blocks.Function(Casing.Fire, `Player: Player, {Values}`, "()", true)
			if IsReliable then
				Fire:Line("Load(PlayersMap[Player])")
				Fire:Line(WriteEvent)
				Fire:Line("PlayersMap[Player] = Save()")
			else
				Fire:Line("Load()")
				Fire:Line(WriteEvent)
				Fire:Multiline(UNRELIABLE_BODY, 1)
				Fire:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
			end
		Fire:End()

		local FireAll = Blocks.Function(Casing.FireAll, Values, "()", true)
			if IsReliable then
				FireAll:Line("Load()")
				FireAll:Line(WriteEvent)
				FireAll:Line(RELIABLE_BODY.Header)
				FireAll:Iterator("_", "Player", "Players:GetPlayers()")
					:Multiline(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireAll:Line("Load()")
				FireAll:Line(WriteEvent)
				FireAll:Multiline(UNRELIABLE_BODY, 1)
				FireAll:Line("Unreliable:FireAllClients(Buffer, SendInstances)")
			end
		FireAll:End()

		local FireList = Blocks.Function(Casing.FireList, `List: \{Player\}, {Values}`, "()", true)
			if IsReliable then
				FireList:Line("Load()")
				FireList:Line(WriteEvent)
				FireList:Line(RELIABLE_BODY.Header)
				FireList:Iterator("_", "Player", "List")
					:Multiline(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireList:Line("Load()")
				FireList:Line(WriteEvent)
				FireList:Multiline(UNRELIABLE_BODY, 1)
				FireList:Iterator("_", "Player", "List")
					:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
				:End()
			end
		FireList:End()

		local FireExcept = Blocks.Function(Casing.FireExcept, `Except: Player, {Values}`, "()", true)
			if IsReliable then
				FireExcept:Line("Load()")
				FireExcept:Line(WriteEvent)
				FireExcept:Line(RELIABLE_BODY.Header)
				FireExcept:Iterator("_", "Player", "Players:GetPlayers()")
					:Compare("Player", "Except", "Equals")
						:Line("continue")
					:End()
					:Multiline(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireExcept:Line("Load()")
				FireExcept:Line(WriteEvent)
				FireExcept:Multiline(UNRELIABLE_BODY, 1)
				FireExcept:Iterator("_", "Player", "Players:GetPlayers()")
					:Compare("Player", "Except", "Equals")
						:Line("continue")
					:End()
					:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
				:End()
			end
		FireExcept:End()

		Body.PushMultiline(Fire:Unwrap() .. ",", 0, Indent + 1)
		Body.PushMultiline(FireAll:Unwrap() .. ",", 0, Indent + 1)
		Body.PushMultiline(FireList:Unwrap() .. ",", 0, Indent + 1)
		Body.PushMultiline(FireExcept:Unwrap() .. ",", 0, Indent + 1)
	end

	Channel.Count += 1

	Body.Push(`\},`, 1, Indent)
	Return.PushMultiline(Body.Dump(), 0)
end

function Declarations.Function(Declaration: Parser.FunctionDeclaration)
	local Value = Declaration.Value
	local DataIdentifier = `FUNCTION_DATA_{Value.Identifier}`
	local ReturnIdentifier = `FUNCTION_RETURN_{Value.Identifier}`

	local Yield = Value.Yield
	local IsFuture = (Yield == "Future")
	local IsPromise = (Yield == "Promise")
	local IsCoroutine = (Yield == "Coroutine")

	if IsFuture and not Options.FutureLibrary then
		error(`Cannot use yield type: "Future", without providing a path to the future library.`)
	end

	if IsPromise and not Options.PromiseLibrary then
		error(`Cannot use yield type: "Promise", without providing a path to the promise library.`)
	end

	local Block = Reliables
	local Channel = Channels.Reliable

	local Index = Channel.Count
	local Queue = `Queue.Reliable[{Index}]`
	local Connection = `Events.Reliable[{Index}]`

	--> Data and return body
	local DataTypes, DataValues, _, DataArguments = Generators.LuauType(Value.Data :: Type, true)
	local ReturnTypes, ReturnValues, _, ReturnArguments = Generators.LuauType(Value.Return :: Type, true)

	do
		local Read, Write = Generators.Event(Value.Data :: Type, Index, DataIdentifier, "Data")
		UserTypes.PushMultiline(Read, 1, 0, false)
		UserTypes.PushMultiline(Write, 1, 0, false)
	end

	do
		local Read, Write = Generators.Event(Value.Return :: Type, Index, ReturnIdentifier, "Return")
		UserTypes.PushMultiline(Read, 1, 0, false)
		UserTypes.PushMultiline(Write, 1, 0, false)
	end

	--> Main
	local Body = Builder.new()
	local Indent = Scope and 2 or 1
	Body.Push(`{Value.Identifier} = \{`, 1, Indent)

	--> Create queue and event branch
	Events.Push(`{Queue} = table.create(256)`)
	Block = (Channel.Listening == false)
		and Block:Compare("Index", Index, "Equals")
		or Block:Branch("Conditional", "Index", Index, "Equals")
	
	--> Update event block to branch block
	Reliables = Block

	if Context == "Server" then
		--> Data recieve body
		Types.u8.Read("local InvocationIdentifier", Block)
		Block:Line(`local {DataValues} = {GetTypesPath(DataIdentifier, Scope, false)}()`)
		:Compare(Connection, "nil", "Not")
			:Line(`{Connection}(Player, {DataArguments}, InvocationIdentifier)`)
		:Branch("Default")
			:Compare(`#{Queue}`, "256", "Greater")
				:Line(`warn("[Blink]: Event queue of \\"{Value.Identifier}\\" exceeded 256, did you forget to implement a listener?")`)
			:End()
			:Line(`table.insert({Queue}, \{Player, {DataArguments}, InvocationIdentifier\} :: \{any\})`)
		:End()

		--> Data listener body
		local FlushQueue = Blocks.Function("", "", "()")
			:Line(`local EventQueue = {Queue} or \{\}`)
			:Line(`{Queue} = nil`)
			:Iterator("Index", "Arguments", "EventQueue")
				:Line(`{Connection}(table.unpack(Arguments))`)
			:End()
		:End()

		local Serialize = Blocks.Function("", "")
			:Line(`local {ReturnValues} = Listener(Player, {DataArguments})`)
			:Line(`SerializationError = true`)
			:Line(`{GetTypesPath(ReturnIdentifier, Scope, true)}({ReturnArguments}, InvocationIdentifier)`)
		:End()

		local TrueListener = Blocks.Function(Connection, `Player: Player, {DataValues}, InvocationIdentifier: number`, "()", true)
			:Line("Load(PlayersMap[Player])")
			:Line("local SerializationError = false")
			:Multiline(`local Success, Error = pcall({Serialize:Unwrap()})`, 1)
			:Compare("Success", "true", "Not")
				:Compare("SerializationError", "true", "Equals")
					:Line(`error(\`Blink failed to serialize function: "{Value.Identifier}", \{Error\}\`)`)
				:End()
				:Line("local Position = Allocate(3)")
				:Line(`buffer.writeu8(SendBuffer, Position, {Index})`)
				:Line(`buffer.writeu8(SendBuffer, Position + 1, InvocationIdentifier)`)
				:Line(`buffer.writeu8(SendBuffer, Position + 2, 0)`)
				:Line(`warn(\`"{Value.Identifier}" encountered an error, \{Error\}\`)`)
			:End()
			:Line("PlayersMap[Player] = Save()")
		:End()

		local Listener = Blocks.Function(Casing.On, `Listener: (Player, {DataTypes}) -> ({ReturnTypes})`, "()", true)
			:Multiline(TrueListener:Unwrap(), 1)
			:Multiline(`task.spawn({FlushQueue:Unwrap()})`, 1)
		:End()

		Body.PushMultiline(Listener:Unwrap(), 0, 2)
	else
		--> Return recieve body
		local Deserialize = Blocks.Function("", "")
			:Return(`{GetTypesPath(ReturnIdentifier, Scope, false)}()`)
		:End()

		Types.u8.Read("local InvocationIdentifier", Block)
		Block:Compare("Calls[InvocationIdentifier]", "nil", "Not")
			:Multiline(`local Success, {ReturnArguments} = pcall({Deserialize:Unwrap()})`, Block.Indent + 1)
			:Line(`task.spawn(Calls[InvocationIdentifier], Success, {ReturnArguments})`)
		:End()

		--> Function listener body
		local Error = `"Server encountered an exception while processing \\"{Value.Identifier}\\"."`
		local Contents = Blocks.Block()
			:Line("local InvocationIdentifier = Invoke()")
			:Line(`{GetTypesPath(DataIdentifier, Scope, true)}({DataArguments}, InvocationIdentifier)`)
			:Line("Calls[InvocationIdentifier] = coroutine.running()")
			:Line(`local Success, {ReturnValues} = coroutine.yield()`)
			:Compare("Success", "true", "Not")
				:Line(`error({Error})`)
			:End()
			:Return(ReturnArguments)
		:Unwrap()

		local Invoke;
		if IsFuture then
			local Wrapper = Blocks.Function("", "")
				:Multiline(Contents)
			:End()

			Invoke = Blocks.Function(Casing.Invoke, DataValues, `Future.Future<{ReturnTypes}>`, true)
			Invoke:Multiline(`return Future.Try({Wrapper:Unwrap()})`, 1)
		elseif IsPromise then
			local OnCancel = Blocks.Function("", "")
				:Line("Calls[InvocationIdentifier] = nil")
			:End()

			local Promise = Blocks.Function("", "Resolve, Reject, OnCancel")
				:Line("local InvocationIdentifier = Invoke()")
				:Line(`{GetTypesPath(DataIdentifier, Scope, true)}({DataArguments}, InvocationIdentifier)`)
				:Line("Calls[InvocationIdentifier] = coroutine.running()")
				:Multiline(`OnCancel({OnCancel:Unwrap()})`, 1)
				:Line(`local Success, {ReturnValues} = coroutine.yield()`)
				:Compare("Success", "true", "Not")
					:Line(`Reject({Error})`)
					:Return("")
				:End()
				:Line(`Resolve({ReturnArguments})`)
			:End()

			Invoke = Blocks.Function(Casing.Invoke, DataValues, `unknown`, true)
			Invoke:Multiline(`return Promise.new({Promise:Unwrap()})`, 1)
		else
			Invoke = Blocks.Function(Casing.Invoke, DataValues, `({ReturnTypes})`, true)
			Invoke:Multiline(Contents, 1)
		end

		Body.PushMultiline(Invoke:End():Unwrap(), 0, 2)
	end

	Channel.Count += 1
	Channel.Listening = true

	Body.Push(`\},`, 1, Indent)
	Return.PushMultiline(Body.Dump(), 0)
end

--> Generator functions
function Generators.Optional(Declaration: Type, Read: Blocks.Block, Write: Blocks.Block, Variable: string, Default: boolean?): (Blocks.Block, Blocks.Block)
	if 
		Declaration.Type == "Primitive" 
		and Declaration.Tokens.Primitive.Value == "Instance" 
		and Default ~= true 
	then
		Read = Read:Compare("typeof(RecieveInstances[RecieveInstanceCursor])", "\"Instance\"", "Equals")
	else
		Types.u8.Write(`{Variable} ~= nil and 1 or 0`, Write)
		Read = Read:Compare(`buffer.readu8(RecieveBuffer, {Read:Read(1)})`, "1", "Equals")
		Write = Write:Compare(Variable, "nil", "Not")
	end

	return Read, Write
end

function Generators.UserType(Declaration: Parser.TypeDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string?)
	local Value = Declaration.Value
	local Array = Value.Array
	local Optional = Value.Optional
	local IsInstance, IsUnknown;

	local Variable = Variable or "Value"
	local ActualVariable = Array and `Item_{Read.Indent}` or Variable

	if Declaration.Type == "Primitive" then
		local Tokens = (Declaration :: Parser.PrimitiveDeclaration).Tokens
		local Primitive = Tokens.Primitive.Value
		IsUnknown = (Primitive == "unknown")
		IsInstance = (Primitive == "Instance")
		Optional = if IsUnknown then true else Optional
	end

	if not _G.BUNDLED then
		Read:Comment(`{Variable}: {Value.Identifier}`)
		Write:Comment(`{Variable}: {Value.Identifier}`)
	end

	--> Instance
	if IsInstance and Array == nil then
		Read:Line("RecieveInstanceCursor += 1")
	end

	--> Array
	if Array then
		if Array.Optional then
			Read, Write = Generators.Optional(Declaration, Read, Write, Variable, true)
		end

		Read:Comment("START ARRAY")
		Write:Comment("START ARRAY")
		Read, Write = Structures.Array(Variable, Read, Write, Array.Bounds, ActualVariable)
		
		if IsInstance then
			Read:Line("RecieveInstanceCursor += 1")
		end
	end

	--> Optional
	if Optional then
		Read, Write = Generators.Optional(Declaration, Read, Write, ActualVariable)
	end

	if Declaration.Type == "Primitive" then
        Declarations.Primitive(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Enum" then
		Declarations.Enum(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Map" then
		Declarations.Map(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Struct" then
		Declarations.Struct(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Tuple" then
		Declarations.Tuple(Declaration, Read, Write)
	elseif Declaration.Type == "Reference" then
		Declarations.Reference(Declaration, Read, Write, ActualVariable)
    end

	if Array then
		Read:Line(`table.insert({Variable}, {ActualVariable})`)
		Read = Read:End()
		Write = Write:End()
		Read:Comment("END ARRAY")
		Write:Comment("END ARRAY")

		if Array.Optional then
			Read = Read:End()
			Write = Write:End()
		end
	end

	if Optional then
		Read:End()
		if not IsInstance then
			Write:End()
		end
	end
end

function Generators.LuauType(Declaration: Parser.TypeDeclaration, UseTypeAsValue: boolean?): (string, string, string, string)
	local Type = ""
	local Values = ""
	local Export = GetExportName(Declaration.Value.Identifier)
	local Returns = "Value"

	if Declaration.Type == "Primitive" then
		local Tokens = (Declaration :: Parser.PrimitiveDeclaration).Tokens
		local Primitive = Primitives[Tokens.Primitive.Value]
		if type(Primitive.Type) == "function" then
			Type = Primitive.Type(Declaration :: Parser.PrimitiveDeclaration)
		else
			Type = Primitive.Type
		end
	elseif Declaration.Type == "Enum" then
		local Value = (Declaration :: Parser.EnumDeclaration).Value
		Type = GenerateEnumLiterals(Value.Values)
	elseif Declaration.Type == "Map" then
		local MapValue = (Declaration :: Parser.MapDeclaration).Value
		local Key = Generators.LuauType(MapValue.Key)
		local Value = Generators.LuauType(MapValue.Value)
		Type = `\{[{Key}]: {Value}\}`
	elseif Declaration.Type == "Struct" then
		local Value = Declaration.Value
		Type = "{ "

		for _, Field in Value.Values do
			local FieldValue = Field.Value
			local Identifier = FieldValue.Identifier
			local FieldType = Generators.LuauType(Field)
			Type ..= `{Identifier}: {FieldType}, `
		end

		Type ..= " }"
	elseif Declaration.Type == "Reference" then
		local Value = (Declaration :: Parser.ReferenceDeclaration).Value
		local Reference = Value.Declaration.Value

		local Name = Reference.Identifier
		local Scope = Reference.Scope
		local Prefix = Scope and `{Scope}_` or ""

		Type = `{Prefix}{Name}` 
	elseif Declaration.Type == "Tuple" then
		local Value = (Declaration :: Parser.TupleDeclaration).Value
		local TupleValues = Value.Values
		Returns = ""

		for Index, TupleValue in TupleValues do
			local Variable = `Value{Index}`
			local ValueType = Generators.LuauType(TupleValue)
			local Seperator = Index < #TupleValues and ", " or ""
			Type ..= `{ValueType}{Seperator}`
			Values ..= `{Variable}: {ValueType}{Seperator}`
			Returns ..= `{Variable}{Seperator}`
		end
	end

	local Value = Declaration.Value
	local Array = Value.Array

	if Value.Optional then
		Type = `({Type})?`
	end

	if Array then
		Type = `\{{Type}\}`
		if Array.Optional then
			Type = `({Type})?`
		end
	end

	--> Generalized type generation, works for everything except tuples
	if Declaration.Type ~= "Tuple" then
		Values = `Value: {UseTypeAsValue and Type or Export}`
	end

	return Type, Values, Export, Returns
end

function Generators.Type(Declaration: Type): (string, string, string)
	local Value = Declaration.Value
	local Identifier = Value.Identifier

	local Type, Values, Export, Returns = Generators.LuauType(Declaration)
	local Read = Blocks.Function(GetTypesPath(Identifier, Scope, false), "", `({Export})`)
	local Write = Blocks.Function(GetTypesPath(Identifier, Scope, true), Values, "()")

	Read:Line(`local {Values};`)
	Generators.UserType(Declaration, Read, Write)

	return `export type {Export} = {Type}`, Read:Return(Returns):End():Unwrap(), Write:End():Unwrap()
end

function Generators.Event(Data: Type, Index: number, Identifier: string, Function: ("Data" | "Return")?): (string, string)
	local Type, Values, _, Returns = Generators.LuauType(Data, true)

	local Arguments = `{Values}{Function and ", InvocationIdentifier: number" or ""}`
	local Read = Blocks.Function(GetTypesPath(Identifier, Scope, false), "", `({Type})`)
	local Write = Blocks.Function(GetTypesPath(Identifier, Scope, true), Arguments, "()")

	if not _G.BUNDLED then
		Write:Comment(`{Identifier} ({Index})`)
	end

	Types.u8.Write(Index, Write)
	if Function then
		Types.u8.Write("InvocationIdentifier", Write)
		if Function == "Return" then
			Types.u8.Write("1", Write)
			Types.u8.Read("local Success", Read)
			Read:Compare("Success", "1", "Not")
				:Line("error(\"Server encountered an error.\")")
			:End()
		end
	end

	Read:Line(`local {Values};`)
	Generators.UserType(Data, Read, Write)

	return Read:Return(Returns):End():Unwrap(), Write:End():Unwrap()
end

function Generators.Scope(Declaration: Parser.ScopeDeclaration)
	local Value = Declaration.Value
	local Identifier = Value.Identifier

	Scope = Identifier
	Return.Push(`{Identifier} = \{`, 1, 1)
	UserTypes.PushFront(`Types.{Identifier} = \{\}`, 2)
	Generators.AbstractSyntaxTree(Value.Values)
	Return.Push(`},`, 1, 1)
	Scope = nil
end

function Generators.AbstractSyntaxTree(Tree: {Parser.Declaration})
	for Index, Declaration in Tree do
		if
			Declaration.Type == "Primitive"
			or Declaration.Type == "Enum"
			or Declaration.Type == "Struct"
			or Declaration.Type == "Map"
		then
			local Export, Read, Write = Generators.Type(Declaration :: any)
			UserTypes.PushMultiline(Read, 1, 0, false)
			UserTypes.PushMultiline(Write, 1, 0, false)
			LuauTypes.PushMultiline(Export, 0, 0, false)
		elseif Declaration.Type == "Scope" then
			Generators.Scope(Declaration :: Parser.ScopeDeclaration)
		elseif Declaration.Type == "Event" then
			Declarations.Event(Declaration :: Parser.EventDeclaration)
		elseif Declaration.Type == "Function" then
			Declarations.Function(Declaration :: Parser.FunctionDeclaration)
		end
	end
end

local Generator = {}

function Generator.Reset()
	--> Setup new builders
	Events = Builder.new()
    UserTypes = Builder.new()
    LuauTypes = Builder.new()
	Return = Builder.new()

	--> Reset channels
	Channels.Reliable.Count = 0
	Channels.Unreliable.Count = 0
	Channels.Reliable.Listening = false
	Channels.Unreliable.Listening = false
end

function Generator.Generate(FileContext: "Client" | "Server", AbstractSyntaxTree: Parser.Body): string
    local Imports = Builder.new()
	
	Generator.Reset()
	Context = FileContext
	Options = AbstractSyntaxTree.Value.Options
	Casing = Settings.GetCasing((Options.Casing :: Settings.Case) or "Pascal")

	--> Setup remote events
	local Signal = Context == "Client" and "OnClientEvent" or "OnServerEvent"
	local Arguments = (Context == "Server" and "Player: Player, " or "") .. "Buffer: buffer, Instances: {Instance}"

	Reliables = Blocks.Connection(`Reliable.{Signal}`, Arguments)
	Unreliables = Blocks.Connection(`Unreliable.{Signal}`, Arguments)

	Reliables:Multiline(EVENT_BODY, 1)
	Unreliables:Multiline(EVENT_BODY, 1)

	Reliables = Reliables:While("RecieveCursor < Size")
	Unreliables = Unreliables:While("RecieveCursor < Size")
	Types.u8.Read("local Index", Reliables)
	Types.u8.Read("local Index", Unreliables)

	--> Import async libraries
	if Options.FutureLibrary then
		Imports.Push(`local Future = require({Options.FutureLibrary})`)
	end

	if Options.PromiseLibrary then
		Imports.Push(`local Promise = require({Options.PromiseLibrary})`)
	end

	--> Replication
	local Replication = Builder.new()
	Return.Push("StepReplication = StepReplication,", 1, 1)

	if not Options.ManualReplication then
		if Context == "Server" then
			Replication.Push("RunService.Heartbeat:Connect(StepReplication)")
		elseif Context == "Client" then
			Replication.Push("local Elapsed = 0")
			local Connection = Blocks.Connection("RunService.Heartbeat", "DeltaTime: number")
				:Line("Elapsed += DeltaTime")
				:Compare("Elapsed", "(1 / 61)", "GreaterOrEquals")
					:Line("Elapsed -= (1 / 61)")
					:Line("StepReplication()")
				:End()
			:End():Unwrap()
			Replication.PushMultiline(Connection)
		end
	end

	--> Parse declarations
	Generators.AbstractSyntaxTree(AbstractSyntaxTree.Value.Declarations)

	--> Generate context source
	local Source = Sources[Context]

	if Channels.Reliable.Listening then
		Reliables = Reliables:End()
	end

	if Channels.Unreliable.Listening then
		Unreliables = Unreliables:End()
	end

	Reliables = Reliables:End():End()
	Unreliables = Unreliables:End():End()

	return DIRECTIVES
		.. VERSION_HEADER
		.. (if not _G.BUNDLED then string.format(DEBUUG_GLOBALS, string.lower(Context), string.lower(Context)) else "")
        .. Source[1]
		.. Imports.Dump()
		.. Sources.Base
		.. Events.Dump() .. "\n"
		.. LuauTypes.Dump() .. "\n"
		.. UserTypes.Dump()
		.. Source[2] .. "\n"
		.. Replication.Dump() .. "\n"
		.. Reliables:Unwrap() .. "\n\n"
		.. Unreliables:Unwrap() .. "\n"
		.. `\nreturn \{\n{Return.Dump()}\}`
end

function Generator.GenerateTypeDefinitions(FileContext: "Client" | "Server", AbstractSyntaxTree: Parser.Body, UserOptions: Parser.Options): string
	Generator.Reset()
	Context = FileContext
	Options = UserOptions

	--> Parse declarations
	Generators.AbstractSyntaxTree(AbstractSyntaxTree.Value)

	return LuauTypes.Dump() 
		.. `\nreturn true`
end

return Generator