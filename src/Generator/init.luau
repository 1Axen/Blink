--!native
--!optimize 2
--!strict

local Blocks = require("./Blocks")
local Parser = require("../Parser")

local Table = require("../Modules/Table")
local Builder = require("../Modules/Builder")

local Prefabs = require("./Prefabs")
local Settings = require("../Settings")

local Sources = {
	Base = require("../Templates/Base"),
	Client = string.split(require("../Templates/Client"), "-- SPLIT --"),
	Server = string.split(require("../Templates/Server"), "-- SPLIT --"),
}

local DIRECTIVES = {"--!strict\n", "--!native\n", "--!optimize 2\n", "--!nolint LocalShadow\n", "--#selene: allow(shadowing)\n"}
local VERSION_HEADER = {`-- File generated by Blink v{_G.VERSION or "0.0.0"} (https://github.com/1Axen/Blink)\n-- This file is not meant to be edited\n\n`}

local EVENT_BODY = {
	"RecieveCursor = 0\n",
	"RecieveBuffer = Buffer\n",
	"RecieveInstances = Instances\n",
	"RecieveInstanceCursor = 0\n",
	"local Size = buffer.len(RecieveBuffer)\n"
}

local RELIABLE_BODY = {
	Header = "local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances",
	Body = {
		"Load(PlayersMap[Player])",
		"local Position = Allocate(Size)",
		"buffer.copy(SendBuffer, Position, Buffer, 0, Size)",
		"table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)",
		"PlayersMap[Player] = Save()",
	}
}

local UNRELIABLE_BODY = {
	"local Buffer = buffer.create(SendCursor)",
	"buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)"
}

local DEBUG_GLOBALS = {
	"local og_typeof = typeof\n",
	"local typeof = function(a: any)\n",
	"\tif type(a) == \"table\" then\n",
	"\t\treturn a.__typeof or \"table\"\n",
	"\tend\n",
	"\treturn og_typeof(a)\n",
	"end\n",
	"local task = require(\"@lune/task\")\n",
	"local game = _G.%s.game\n",
}

type Type = Parser.TypeDeclaration
type Scope = Parser.Scope

local Scope: Scope;
local Context: string;
local Casing: Settings.Cases;
local Events: Builder.Builder;
local UserTypes: Builder.Builder;
local LuauTypes: Builder.Builder;
local Reliables: Blocks.Block;
local Unreliables: Blocks.Block;
local Return: Builder.Builder;
local Options: Parser.Options;

local Generators = {}
local Declarations = {}

local Channels: { [string]: { Count: number, Listening: boolean } } = {
	Reliable = { Count = 0, Listening = false },
	Unreliable = { Count = 0, Listening = false },
}

local Types = Prefabs.Types
local Primitives = Prefabs.Primitives
local Structures = Prefabs.Structures

--> Utility functions

local function GetScopePrefix(ReferenceScope: Scope?, Dots: boolean?): string
	local Prefix = ""
	local WorkingScope: Scope? = ReferenceScope or Scope
	while (WorkingScope and WorkingScope.Identifier ~= "") do
		Prefix = `{WorkingScope.Identifier}{Dots and "." or "_"}` .. Prefix
		WorkingScope = WorkingScope.Parent
	end

	return Prefix
end


local function GetScopeIndent(): number
	return math.max(#string.split(GetScopePrefix(nil, true), "."), 1)
end

local function GetTypesPath(Identifier: string, Write: boolean): string
	return `Types.{GetScopePrefix()}{Write and "Write" or "Read"}{Identifier}`
end

local function GetExportName(Identifier: string): string
	return `{GetScopePrefix()}{Identifier}`
end

local function GenerateEnumLiterals(Enums: { string }): string
	local Literal = ""
	for Index, EnumItem in Enums do
		Literal ..= `"{EnumItem}"{Index < #Enums and " | " or ""}`
	end
	return Literal
end

--> Declaration functions

function Declarations.Primitive(Declaration: Parser.PrimitiveDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Tokens = Declaration.Tokens
	local Primitive = Tokens.Primitive.Value
    local Generator = Primitives[Primitive]
    Generator.Generate(Declaration, Variable, Read, Write, Options.WriteValidations)
end

function Declarations.Enum(Declaration: Parser.EnumDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Enums = Value.Values
	local Literal = GenerateEnumLiterals(Enums)
	Literal = string.gsub(Literal, "|", "or")

	--> Read body
	Types.u8.Read(`local Index`, Read)
	Read = Read:Compare("Index", "0", "Equals")
		for Index, EnumItem in Enums do
			if Index > 1 then
				Read = Read:Branch("Conditional", "Index", `{Index - 1}`, "Equals")
			end

			Read:Line(`{Variable} = "{EnumItem}"`)
		end
	Read:Branch("Default")
		:Line(`error(\`Unexpected enum: \{Index\}\`)`)
	:End()

	--> Write body
	local Allocation = Write:Allocate(1)
		for Index, EnumItem in Enums do
			if Index == 1 then
				Write = Write:Compare(Variable, `"{EnumItem}"`, "Equals")
			else
				Write = Write:Branch("Conditional", Variable, `"{EnumItem}"`, "Equals")
			end

			Write:Line(`buffer.writeu8(SendBuffer, {Allocation}, {Index - 1})`)
		end
	Write:Branch("Default")
		:Line(`error(\`Unexpected enum: \{{Variable}\}, expectd one of {Literal}.\`)`)
	:End()
end

function Declarations.Map(Declaration: Parser.MapDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local MapValue = Declaration.Value
	local Key = MapValue.Key
	local Value = MapValue.Value

	local KeyType = Generators.LuauType(Key :: Type)
	local ValueType = Generators.LuauType(Value :: Type)

	Read:Line(`{Variable} = \{\}`)
	Write:Line("local Elements = 0")
	Types.u16.Read(`local Elements`, Read)

	local ReadLoop = Read:Loop("_ = 1", "Elements")
	local WriteLoop = Write:Iterator("Key", "Element", Variable)

	ReadLoop:Line(`local Key: {KeyType}, Element: {ValueType};`)
	WriteLoop:Line("Elements += 1")
	Generators.UserType(Key :: Type, ReadLoop, WriteLoop, "Key")
	Generators.UserType(Value :: Type, ReadLoop, WriteLoop, "Element")
	ReadLoop:Line(`{Variable}[Key] = Element`)

	WriteLoop:End()
	ReadLoop:End()

	Write:Line(`buffer.writeu16(SendBuffer, {Write:Allocate(2)}, Elements)`)
end

function Declarations.Struct(Declaration: Parser.StructDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	Read:Line(`{Variable} = \{\} :: any`)

	for _, Field in Value.Values do
		local FieldValue = Field.Value
		local Identifier = FieldValue.Identifier
		local FieldVariable = `{Variable}.{Identifier}`
		Generators.UserType(Field :: Type, Read, Write, FieldVariable)
	end
end

function Declarations.Tuple(Declaration: Parser.TupleDeclaration, Read: Blocks.Block, Write: Blocks.Block)
	for Index, Value in Declaration.Value.Values do
		local Variable = `Value{Index}`
		Generators.UserType(Value :: Type, Read, Write, Variable)
	end
end

function Declarations.Reference(Declaration: Parser.ReferenceDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
    local Value = Declaration.Value
	local Reference = Value.Declaration

	--> Inline reference
	Generators.UserType(Reference, Read, Write, Variable)
end

function Declarations.TagEnum(Declaration: Parser.TagEnumDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Values = Value.Values

	--> Body
	local Tag = Value.Tag
	local Header = `"{Values[1].Name}"`
	local TagIndex = `{Variable}.{Tag}`

	Types.u8.Read(`local Tag`, Read)

	Read = Read:Compare("Tag", "0", "Equals")
	Write = Write:Compare(TagIndex, Header, "Equals")

	for Index, Variant in Values do
		local Name = `"{Variant.Name}"` 

		if Index > 1 then
			Read = Read:Branch("Conditional", "Tag", tostring(Index - 1), "Equals")
			Write = Write:Branch("Conditional", TagIndex, Name, "Equals")
		end

		Types.u8.Write(tostring(Index - 1), Write)
		Generators.UserType(Variant.Value, Read, Write)
		Read:Line(`{TagIndex} = {Name}`)
	end

	Read:Branch("Default")
		:Line(`error(\`Unexpected variant: \{Tag\}\`)`)
	:End()
	
	Write:Branch("Default")
		:Line(`error(\`Unexpected variant: \{{TagIndex}\}\`)`)
	:End()
end

function Declarations.Event(Declaration: Parser.EventDeclaration)
	local Value = Declaration.Value

	local Identifier = `EVENT_{Value.Identifier}`
	local Reliability = Value.Type

	local IsReliable = (Reliability == "Reliable")
	local IsUnreliable = (Reliability == "Unreliable")

	local Block = IsUnreliable and Unreliables or Reliables
	local Channel = IsUnreliable and Channels.Unreliable or Channels.Reliable

	local Index = Channel.Count
	local Queue = `Queue.{Reliability}[{Index}]`
	local Connection = `Events.{Reliability}[{Index}]`

	--> Data body
	local _, Values, _, Arguments = Generators.LuauType(Value.Data :: Type, true)
	local Read, Write = Generators.Event(Value.Data :: Type, Index, Identifier)
	UserTypes.PushLines(Read, 1, 0)
	UserTypes.PushLines(Write, 1, 0)

	--> Return body
	local Body = Builder.new()
	local Indent = GetScopeIndent()
	local WriteEvent = `{GetTypesPath(Identifier, true)}({Arguments})`
	Body.Push(`{Value.Identifier} = \{`, 0, Indent)

	if Value.From ~= Context then
		--> Create queue and event branch
		Events.Push(`{Queue} = table.create(256)`)
		Block = (Channel.Listening == false)
			and Block:Compare("Index", Index, "Equals")
			or Block:Branch("Conditional", "Index", Index, "Equals")
	
		--> Update event block to branch block
		if IsUnreliable then
			Unreliables = Block
		else
			Reliables = Block
		end
		
		--> Update channel status
		Channel.Listening = true

		--> Event recieve body
		local Listener: Blocks.Block;
		local ContextArguments = `Listener: ({Context == "Server" and "Player: Player, " or ""}{Values}) -> ()`
		local ListenerArguments = `{Context == "Server" and "Player, " or ""}{Arguments}`
		local CallListenerFunction = Value.Call == "SingleSync" and `{Connection}({ListenerArguments})` or `task.spawn({Connection}, {ListenerArguments})`

		Block:Line(`local {Values} = {GetTypesPath(Identifier, false)}()`)

		if IsReliable then
			Block:Compare(Connection, "nil", "Not")
				:Line(CallListenerFunction)
			:Branch("Default")
				:Compare(`#{Queue}`, "256", "Greater")
					:Line(`warn("[Blink]: Event queue of \\"{Value.Identifier}\\" exceeded 256, did you forget to implement a listener?")`)
				:End()
				:Line(`table.insert({Queue}, \{{ListenerArguments}\} :: \{any\})`)
			:End()

			local Disconnect = Blocks.Function("", "", "()")
				:Line(`{Queue} = \{\}`)
				:Line(`{Connection} = nil`)
			:End()
			:Wrap("return ", "")

			local FlushQueue = Blocks.Function("", "", "()")
				:Line(`local EventQueue = {Queue} or \{\}`)
				:Line(`{Queue} = nil`)
				:Iterator("Index", "Arguments", "EventQueue")
					:Line(Value.Call == "SingleSync" and `Listener(table.unpack(Arguments))` or `task.spawn(Listener, table.unpack(Arguments))`)
				:End()
			:End()
			:Wrap("task.spawn(", ")")

			Listener = Blocks.Function(Casing.On, ContextArguments, `() -> ()`, true)
				:Line(`{Connection} = Listener`)
				:Lines(FlushQueue.Content, 1)
				:Lines(Disconnect.Content, 1)
			:End()
		else
			Block:Compare(Connection, "nil", "Not")
				:Line(CallListenerFunction)
			:End()

			local Disconnect = Blocks.Function("", "", "()")
				:Line(`{Connection} = nil`)
			:End()
			:Wrap("return ", "")

			Listener = Blocks.Function(Casing.On, ContextArguments, `() -> ()`, true)
				:Line(`{Connection} = Listener`)
				:Lines(Disconnect.Content, 1)
			:End()
		end

		Body.PushLines(Listener.Content, 0, Indent + 1)
	elseif Context == "Client" then
		local Fire = Blocks.Function(Casing.Fire, Values, "()", true)
			if IsReliable then
				Fire:Line(WriteEvent)
			else
				Fire:Line(`local Previous = Save()`)
				Fire:Line(`Load()`)
				Fire:Line(WriteEvent)
				Fire:Line("local Buffer = buffer.create(SendCursor)")
				Fire:Line("buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)")
				Fire:Line("Unreliable:FireServer(Buffer, SendInstances)")
				Fire:Line("Load(Previous)")
			end
		Fire:End()
		Body.PushLines(Fire.Content, 0, Indent + 1)
	else
		local Fire = Blocks.Function(Casing.Fire, `Player: Player, {Values}`, "()", true)
			if IsReliable then
				Fire:Line("Load(PlayersMap[Player])")
				Fire:Line(WriteEvent)
				Fire:Line("PlayersMap[Player] = Save()")
			else
				Fire:Line("Load()")
				Fire:Line(WriteEvent)
				Fire:Lines(UNRELIABLE_BODY, 1)
				Fire:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
			end
		Fire:End()

		local FireAll = Blocks.Function(Casing.FireAll, Values, "()", true)
			if IsReliable then
				FireAll:Line("Load()")
				FireAll:Line(WriteEvent)
				FireAll:Line(RELIABLE_BODY.Header)
				FireAll:Iterator("_", "Player", "Players:GetPlayers()")
					:Lines(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireAll:Line("Load()")
				FireAll:Line(WriteEvent)
				FireAll:Lines(UNRELIABLE_BODY, 1)
				FireAll:Line("Unreliable:FireAllClients(Buffer, SendInstances)")
			end
		FireAll:End()

		local FireList = Blocks.Function(Casing.FireList, `List: \{Player\}, {Values}`, "()", true)
			if IsReliable then
				FireList:Line("Load()")
				FireList:Line(WriteEvent)
				FireList:Line(RELIABLE_BODY.Header)
				FireList:Iterator("_", "Player", "List")
					:Lines(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireList:Line("Load()")
				FireList:Line(WriteEvent)
				FireList:Lines(UNRELIABLE_BODY, 1)
				FireList:Iterator("_", "Player", "List")
					:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
				:End()
			end
		FireList:End()

		local FireExcept = Blocks.Function(Casing.FireExcept, `Except: Player, {Values}`, "()", true)
			if IsReliable then
				FireExcept:Line("Load()")
				FireExcept:Line(WriteEvent)
				FireExcept:Line(RELIABLE_BODY.Header)
				FireExcept:Iterator("_", "Player", "Players:GetPlayers()")
					:Compare("Player", "Except", "Equals")
						:Line("continue")
					:End()
					:Lines(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireExcept:Line("Load()")
				FireExcept:Line(WriteEvent)
				FireExcept:Lines(UNRELIABLE_BODY, 1)
				FireExcept:Iterator("_", "Player", "Players:GetPlayers()")
					:Compare("Player", "Except", "Equals")
						:Line("continue")
					:End()
					:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
				:End()
			end
		FireExcept:End()

		Body.PushLines(Fire:Wrap("", ",").Content, 0, Indent + 1)
		Body.PushLines(FireAll:Wrap("", ",").Content, 0, Indent + 1)
		Body.PushLines(FireList:Wrap("", ",").Content, 0, Indent + 1)
		Body.PushLines(FireExcept:Wrap("", ",").Content, 0, Indent + 1)
	end

	Channel.Count += 1

	Body.Push(`\},`, 0, Indent)
	Return.PushLines(Body.DumpLines(), 0)
end

function Declarations.Function(Declaration: Parser.FunctionDeclaration)
	local Value = Declaration.Value
	local DataIdentifier = `FUNCTION_DATA_{Value.Identifier}`
	local ReturnIdentifier = `FUNCTION_RETURN_{Value.Identifier}`

	local Yield = Value.Yield
	local IsFuture = (Yield == "Future")
	local IsPromise = (Yield == "Promise")
	local IsCoroutine = (Yield == "Coroutine")

	if IsFuture and not Options.FutureLibrary then
		error(`Cannot use yield type: "Future", without providing a path to the future library.`)
	end

	if IsPromise and not Options.PromiseLibrary then
		error(`Cannot use yield type: "Promise", without providing a path to the promise library.`)
	end

	local Block = Reliables
	local Channel = Channels.Reliable

	local Index = Channel.Count
	local Queue = `Queue.Reliable[{Index}]`
	local Connection = `Events.Reliable[{Index}]`

	--> Data and return body
	local DataTypes, DataValues, _, DataArguments = Generators.LuauType(Value.Data :: Type, true)
	local ReturnTypes, ReturnValues, _, ReturnArguments = Generators.LuauType(Value.Return :: Type, true)

	do
		local Read, Write = Generators.Event(Value.Data :: Type, Index, DataIdentifier, "Data")
		UserTypes.PushLines(Read, 1, 0)
		UserTypes.PushLines(Write, 1, 0)
	end

	do
		local Read, Write = Generators.Event(Value.Return :: Type, Index, ReturnIdentifier, "Return")
		UserTypes.PushLines(Read, 1, 0)
		UserTypes.PushLines(Write, 1, 0)
	end

	--> Main
	local Body = Builder.new()
	local Indent = GetScopeIndent()
	Body.Push(`{Value.Identifier} = \{`, 0, Indent)

	--> Create queue and event branch
	Events.Push(`{Queue} = table.create(256)`)
	Block = (Channel.Listening == false)
		and Block:Compare("Index", Index, "Equals")
		or Block:Branch("Conditional", "Index", Index, "Equals")
	
	--> Update event block to branch block
	Reliables = Block

	if Context == "Server" then
		--> Data recieve body
		Types.u8.Read("local InvocationIdentifier", Block)
		Block:Line(`local {DataValues} = {GetTypesPath(DataIdentifier, false)}()`)
		:Compare(Connection, "nil", "Not")
			:Line(`{Connection}(Player, {DataArguments}, InvocationIdentifier)`)
		:Branch("Default")
			:Compare(`#{Queue}`, "256", "Greater")
				:Line(`warn("[Blink]: Event queue of \\"{Value.Identifier}\\" exceeded 256, did you forget to implement a listener?")`)
			:End()
			:Line(`table.insert({Queue}, \{Player, {DataArguments}, InvocationIdentifier\} :: \{any\})`)
		:End()

		--> Data listener body
		local FlushQueue = Blocks.Function("", "", "()")
			:Line(`local EventQueue = {Queue} or \{\}`)
			:Line(`{Queue} = nil`)
			:Iterator("Index", "Arguments", "EventQueue")
				:Line(`{Connection}(table.unpack(Arguments))`)
			:End()
		:End()
		:Wrap("task.spawn(", ")")

		local Serialize = Blocks.Function("", "")
			:Line(`local {ReturnValues} = Listener(Player, {DataArguments})`)
			:Line(`SerializationError = true`)
			:Line(`{GetTypesPath(ReturnIdentifier, true)}({ReturnArguments}, InvocationIdentifier)`)
		:End()
		:Wrap("local Success, Error = pcall(", ")")

		local TrueListener = Blocks.Function(Connection, `Player: Player, {DataValues}, InvocationIdentifier: number`, "()", true)
			:Line("Load(PlayersMap[Player])")
			:Line("local SerializationError = false")
			:Lines(Serialize.Content, 1)
			:Compare("Success", "true", "Not")
				:Compare("SerializationError", "true", "Equals")
					:Line(`error(\`Blink failed to serialize function: "{Value.Identifier}", \{Error\}\`)`)
				:End()
				:Line("local Position = Allocate(3)")
				:Line(`buffer.writeu8(SendBuffer, Position, {Index})`)
				:Line(`buffer.writeu8(SendBuffer, Position + 1, InvocationIdentifier)`)
				:Line(`buffer.writeu8(SendBuffer, Position + 2, 0)`)
				:Line(`warn(\`"{Value.Identifier}" encountered an error, \{Error\}\`)`)
			:End()
			:Line("PlayersMap[Player] = Save()")
		:End()

		local Listener = Blocks.Function(Casing.On, `Listener: (Player, {DataTypes}) -> ({ReturnTypes})`, "()", true)
			:Lines(TrueListener.Content, 1)
			:Lines(FlushQueue.Content, 1)
		:End()

		Body.PushLines(Listener.Content, 0, 2)
	else
		--> Return recieve body
		local Deserialize = Blocks.Function("", "")
			:Return(`{GetTypesPath(ReturnIdentifier, false)}()`)
		:End()
		:Wrap(`local Success, {ReturnArguments} = pcall(`, ")")

		Types.u8.Read("local InvocationIdentifier", Block)
		Block:Compare("Calls[InvocationIdentifier]", "nil", "Not")
			:Lines(Deserialize.Content, Block.Indent + 1)
			:Line(`task.spawn(Calls[InvocationIdentifier], Success, {ReturnArguments})`)
		:End()

		--> Function listener body
		local Error = `"Server encountered an exception while processing \\"{Value.Identifier}\\"."`
		local Contents = Blocks.Block()
			:Line("local InvocationIdentifier = Invoke()")
			:Line(`{GetTypesPath(DataIdentifier, true)}({DataArguments}, InvocationIdentifier)`)
			:Line("Calls[InvocationIdentifier] = coroutine.running()")
			:Line(`local Success, {ReturnValues} = coroutine.yield()`)
			:Compare("Success", "true", "Not")
				:Line(`error({Error})`)
			:End()
		:Return(ReturnArguments).Content

		local Invoke;
		if IsFuture then
			local Wrapper = Blocks.Function("", "")
				:Lines(Contents)
			:End()
			:Wrap("return Future.Try(", ")")

			Invoke = Blocks.Function(Casing.Invoke, DataValues, `Future.Future<{ReturnTypes}>`, true)
			Invoke:Lines(Wrapper.Content, 1)
		elseif IsPromise then
			local OnCancel = Blocks.Function("", "")
				:Line("Calls[InvocationIdentifier] = nil")
			:End()
			:Wrap("OnCancel(", ")")

			local Promise = Blocks.Function("", "Resolve, Reject, OnCancel")
				:Line("local InvocationIdentifier = Invoke()")
				:Line(`{GetTypesPath(DataIdentifier, true)}({DataArguments}, InvocationIdentifier)`)
				:Line("Calls[InvocationIdentifier] = coroutine.running()")
				:Lines(OnCancel.Content, 1)
				:Line(`local Success, {ReturnValues} = coroutine.yield()`)
				:Compare("Success", "true", "Not")
					:Line(`Reject({Error})`)
					:Return("")
				:End()
				:Line(`Resolve({ReturnArguments})`)
			:End()
			:Wrap(`return Promise.new(`, ")")

			Invoke = Blocks.Function(Casing.Invoke, DataValues, `unknown`, true)
			Invoke:Lines(Promise.Content, 1)
		else
			Invoke = Blocks.Function(Casing.Invoke, DataValues, `({ReturnTypes})`, true)
			Invoke:Lines(Contents, 0)
		end

		Invoke:End()
		Body.PushLines(Invoke.Content, 0, Indent + 1)
	end

	Channel.Count += 1
	Channel.Listening = true

	Body.Push(`\},`, 0, Indent)
	Return.PushLines(Body.DumpLines(), 0)
end

--> Generator functions
function Generators.Optional(Declaration: Type, Read: Blocks.Block, Write: Blocks.Block, Variable: string, Default: boolean?): (Blocks.Block, Blocks.Block)
	if 
		Declaration.Type == "Primitive" 
		and Declaration.Tokens.Primitive.Value == "Instance" 
		and Default ~= true 
	then
		Read = Read:Compare("typeof(RecieveInstances[RecieveInstanceCursor])", "\"Instance\"", "Equals")
	else
		Types.u8.Write(`{Variable} ~= nil and 1 or 0`, Write)
		Read = Read:Compare(`buffer.readu8(RecieveBuffer, {Read:Read(1)})`, "1", "Equals")
		Write = Write:Compare(Variable, "nil", "Not")
	end

	return Read, Write
end

function Generators.UserType(Declaration: Type, Read: Blocks.Block, Write: Blocks.Block, Variable: string?)
	local Value = Declaration.Value
	local Array = Value.Array
	local Optional = Value.Optional
	local IsInstance, IsUnknown;

	local Variable = Variable or "Value"
	local ActualVariable = Array and `Item_{Read.Indent}` or Variable

	if Declaration.Type == "Primitive" then
		local Tokens = (Declaration :: Parser.PrimitiveDeclaration).Tokens
		local Primitive = Tokens.Primitive.Value
		IsUnknown = (Primitive == "unknown")
		IsInstance = (Primitive == "Instance")
		Optional = if IsUnknown then true else Optional
	end

	if not _G.BUNDLED then
		Read:Comment(`{Variable}: {Value.Identifier}`)
		Write:Comment(`{Variable}: {Value.Identifier}`)
	end

	--> Instance
	if IsInstance and Array == nil then
		Read:Line("RecieveInstanceCursor += 1")
	end

	--> Array
	if Array then
		if Array.Optional then
			Read, Write = Generators.Optional(Declaration, Read, Write, Variable, true)
		end

		Read:Comment("START ARRAY")
		Write:Comment("START ARRAY")
		Read, Write = Structures.Array(Variable, Read, Write, Array.Bounds, ActualVariable)
		
		if IsInstance then
			Read:Line("RecieveInstanceCursor += 1")
		end
	end

	--> Optional
	if Optional then
		Read, Write = Generators.Optional(Declaration, Read, Write, ActualVariable)
	end

	if Declaration.Type == "Primitive" then
        Declarations.Primitive(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Enum" then
		Declarations.Enum(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Map" then
		Declarations.Map(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Struct" then
		Declarations.Struct(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Tuple" then
		Declarations.Tuple(Declaration, Read, Write)
	elseif Declaration.Type == "TagEnum" then
		Declarations.TagEnum(Declaration, Read, Write, ActualVariable)
	elseif Declaration.Type == "Reference" then
		Declarations.Reference(Declaration, Read, Write, ActualVariable)
    end

	if Array then
		Read:Line(`table.insert({Variable}, {ActualVariable})`)
		Read = Read:End()
		Write = Write:End()
		Read:Comment("END ARRAY")
		Write:Comment("END ARRAY")

		if Array.Optional then
			Read = Read:End()
			Write = Write:End()
		end
	end

	if Optional then
		Read:End()
		if not IsInstance then
			Write:End()
		end
	end
end

function Generators.LuauType(Declaration: Type, UseTypeAsValue: boolean?): (string, string, string, string)
	local Type = ""
	local Values = ""
	local Export = GetExportName(Declaration.Value.Identifier)
	local Returns = "Value"

	if Declaration.Type == "Primitive" then
		local Tokens = (Declaration :: Parser.PrimitiveDeclaration).Tokens
		local Primitive = Primitives[Tokens.Primitive.Value]
		if type(Primitive.Type) == "function" then
			Type = Primitive.Type(Declaration :: Parser.PrimitiveDeclaration)
		else
			Type = Primitive.Type
		end
	elseif Declaration.Type == "Enum" then
		local Value = (Declaration :: Parser.EnumDeclaration).Value
		Type = GenerateEnumLiterals(Value.Values)
	elseif Declaration.Type == "TagEnum" then
		local Value = (Declaration :: Parser.TagEnumDeclaration).Value
		local Size  = #Value.Values
		for Index, Variant in Value.Values do
			local TagField = `{Value.Tag}: "{Variant.Name}"`
			local ValueType = Generators.LuauType(Variant.Value)
			Type ..= `\{ {TagField},{string.sub(ValueType, 2)}{Index ~= Size and " | " or ""}`
		end
	elseif Declaration.Type == "Map" then
		local MapValue = (Declaration :: Parser.MapDeclaration).Value
		local Key = Generators.LuauType(MapValue.Key)
		local Value = Generators.LuauType(MapValue.Value)
		Type = `\{[{Key}]: {Value}\}`
	elseif Declaration.Type == "Struct" then
		local Value = Declaration.Value
		Type = "{ "

		for _, Field in Value.Values do
			local FieldValue = Field.Value
			local Identifier = FieldValue.Identifier
			local FieldType = Generators.LuauType(Field)
			Type ..= `{Identifier}: {FieldType}, `
		end

		Type ..= " }"
	elseif Declaration.Type == "Generic" then
		Type = `{Declaration.Value.Generic}`
	elseif Declaration.Type == "Reference" then
		local Value = (Declaration :: Parser.ReferenceDeclaration).Value
		local Reference = Value.Declaration.Value
		Type = `{GetScopePrefix(Reference.Scope)}{Reference.Identifier}` 
	elseif Declaration.Type == "Tuple" then
		local Value = (Declaration :: Parser.TupleDeclaration).Value
		local TupleValues = Value.Values
		Returns = ""

		for Index, TupleValue in TupleValues do
			local Variable = `Value{Index}`
			local ValueType = Generators.LuauType(TupleValue)
			local Seperator = Index < #TupleValues and ", " or ""
			Type ..= `{ValueType}{Seperator}`
			Values ..= `{Variable}: {ValueType}{Seperator}`
			Returns ..= `{Variable}{Seperator}`
		end
	end

	local Value = Declaration.Value
	local Array = Value.Array

	if Value.Optional then
		Type = `({Type})?`
	end

	if Array then
		Type = `\{{Type}\}`
		if Array.Optional then
			Type = `({Type})?`
		end
	end

	if Value.Parameters then
		local Parameters = ""
		local Maximum = #Value.Parameters

		--> Generate luau types for parameters
		for Index, Parameter in Value.Parameters do
			Parameters ..= Generators.LuauType(Parameter)
			
			if Index ~= Maximum then
				Parameters ..= ","
			end
		end

		--> Wrap in chevrons
		Parameters = `<{Parameters}>`
		Type = `{Type}{Parameters}`
	end

	--> Generalized type generation, works for everything except tuples
	if Declaration.Type ~= "Tuple" then
		Values = `Value: {UseTypeAsValue and Type or Export}`
	end

	return Type, Values, Export, Returns
end

function Generators.Type(Declaration: Type)
	local Value = Declaration.Value
	local Identifier = Value.Identifier
	local Type, Values, Export, Returns = Generators.LuauType(Declaration)

	local Read = Blocks.Function(GetTypesPath(Identifier, false), "", `({Export})`)
	local Write = Blocks.Function(GetTypesPath(Identifier, true), Values, "()")

	local Generics = ""
	if Value.Generics then
		for Generic in Value.Generics.Indices do
			Generics ..= `{Generic},`
		end

		Generics = string.sub(Generics, 1, #Generics - 1)
		Generics = `<{Generics}>`
	else
		Read:Line(`local {Values};`)
		Generators.UserType(Declaration, Read, Write)
		Read:Return(Returns)

		Read:End()
		Write:End()

		UserTypes.PushLines(Read.Content, 1, 0)
		UserTypes.PushLines(Write.Content, 1, 0)
	end

	--> Write luau export
	LuauTypes.PushMultiline(`export type {Export}{Generics} = {Type}`, 1, 0)
end

function Generators.Export(Declaration: Type)
	local Value = Declaration.Value
	local Identifier = Value.Identifier
	local _, Values, Export, Returns = Generators.LuauType(Declaration)

	local Arguments = "Buffer: buffer"
	local Read = Blocks.Function("Read", Arguments, `({Export})`, true)
	local Write = Blocks.Function("Write", `{Arguments}, {Values}`, `()`, true)

	local Body = Builder.new()
	local Indent = GetScopeIndent()
	Body.Push(`{Identifier} = \{`, 0, Indent)

	--> Overwrite buffer
	Read:Comment("Buffer overwrite")
	Write:Comment("Buffer overwrite")

	Read:Lines({
		"local PreviousCursor = RecieveCursor\n",
		"local PreviousBuffer = RecieveBuffer\n",
		"local PreviousInstanceCursor = RecieveInstanceCursor\n",
		"RecieveCursor = buffer.len(Buffer)\n",
		"RecieveBuffer = Buffer\n",
	}, 1)

	Write:Lines({
		"local Previous = Save()\n",
		"SendSize = buffer.len(Buffer)\n",
		"SendCursor = SendSize\n",
		"SendOffset = SendSize\n",
		"SendBuffer = Buffer\n",
	}, 1)

	Read:Advance(#Read.Content - 1)
	Write:Advance(#Write.Content - 1)

	--> Write to buffer
	Read:Comment("Buffer read")
	Write:Comment("Buffer write")

	Read:Line(`local {Values} = {GetTypesPath(Identifier, false)}()`)
	Write:Line(`{GetTypesPath(Identifier, true)}({Returns})`)

	--> Restore buffer
	Read:Comment("Buffer restore")
	Write:Comment("Buffer restore")
	
	Read:Lines({
		"RecieveCursor = PreviousCursor\n",
		"RecieveBuffer = PreviousBuffer\n",
		"RecieveInstanceCursor = PreviousInstanceCursor\n",
	}, 1)

	Write:Line(`Load(Previous)`)

	--> End export
	Read:Return(Returns)
	Read:End():Wrap("", ",")
	Write:End()

	Body.PushLines(Read.Content, 0, Indent + 1)
	Body.PushLines(Write.Content, 0, Indent + 1)
	Body.Push(`\},`, 0, Indent)

	Return.PushLines(Body.DumpLines(), 0)
end

function Generators.Event(Data: Type, Index: number, Identifier: string, Function: ("Data" | "Return")?): ({string}, {string})
	local Type, Values, _, Returns = Generators.LuauType(Data, true)

	local Arguments = `{Values}{Function and ", InvocationIdentifier: number" or ""}`
	local Read = Blocks.Function(GetTypesPath(Identifier, false), "", `({Type})`)
	local Write = Blocks.Function(GetTypesPath(Identifier, true), Arguments, "()")

	if not _G.BUNDLED then
		Write:Comment(`{Identifier} ({Index})`)
	end

	Types.u8.Write(Index, Write)
	if Function then
		Types.u8.Write("InvocationIdentifier", Write)
		if Function == "Return" then
			Types.u8.Write("1", Write)
			Types.u8.Read("local Success", Read)
			Read:Compare("Success", "1", "Not")
				:Line("error(\"Server encountered an error.\")")
			:End()
		end
	end

	Read:Line(`local {Values};`)
	Generators.UserType(Data, Read, Write)

	return Read:Return(Returns):End().Content, Write:End().Content
end

function Generators.Scope(Declaration: Parser.ScopeDeclaration)
	local Value = Declaration.Value
	local Identifier = Value.Identifier

	local Parent = Scope
	local NewScope = Value.Scope

	local Path = GetScopePrefix(NewScope, true)
	local Indent = (#string.split(Path, ".") - 1)
	Path = string.sub(Path, 1, #Path - 1)

	Scope = NewScope
	Events.Push(`Types.{Path} = \{\}`, 1, 0)
	Return.Push(`{Identifier} = \{`, 0, Indent)
	Generators.AbstractSyntaxTree(Value.Values)
	Return.Push(`},`, 0, Indent)
	Scope = Parent
end

function Generators.AbstractSyntaxTree(Tree: {Parser.Declaration})
	for Index, Declaration in Tree do
		if
			Declaration.Type == "Primitive"
			or Declaration.Type == "Enum"
			or Declaration.Type == "Struct"
			or Declaration.Type == "Map"
			or Declaration.Type == "TagEnum"
		then
			if Declaration.Value.Export then
				Generators.Export(Declaration :: Type)
			end

			Generators.Type(Declaration :: Type)
		elseif Declaration.Type == "Scope" then
			Generators.Scope(Declaration :: Parser.ScopeDeclaration)
		elseif Declaration.Type == "Event" then
			Declarations.Event(Declaration :: Parser.EventDeclaration)
		elseif Declaration.Type == "Function" then
			Declarations.Function(Declaration :: Parser.FunctionDeclaration)
		end
	end
end

local Generator = {}

function Generator.Reset()
	--> Setup new builders
	Events = Builder.new()
    UserTypes = Builder.new()
    LuauTypes = Builder.new()
	Return = Builder.new()

	--> Reset channels
	Channels.Reliable.Count = 0
	Channels.Unreliable.Count = 0
	Channels.Reliable.Listening = false
	Channels.Unreliable.Listening = false
end

function Generator.Generate(FileContext: "Client" | "Server", AbstractSyntaxTree: Parser.Body): string
    local Imports = Builder.new()
	
	Generator.Reset()
	Context = FileContext
	Options = AbstractSyntaxTree.Value.Options
	Casing = Settings.GetCasing((Options.Casing :: Settings.Case) or "Pascal")

	--> Setup remote events
	local Signal = Context == "Client" and "OnClientEvent" or "OnServerEvent"
	local Arguments = (Context == "Server" and "Player: Player, " or "") .. "Buffer: buffer, Instances: {Instance}"

	Reliables = Blocks.Connection(`Reliable.{Signal}`, Arguments)
	Unreliables = Blocks.Connection(`Unreliable.{Signal}`, Arguments)

	Reliables:Lines(EVENT_BODY, 1)
	Unreliables:Lines(EVENT_BODY, 1)

	Reliables = Reliables:While("RecieveCursor < Size")
	Unreliables = Unreliables:While("RecieveCursor < Size")
	Types.u8.Read("local Index", Reliables)
	Types.u8.Read("local Index", Unreliables)

	--> Import async libraries
	if Options.FutureLibrary then
		Imports.Push(`local Future = require({Options.FutureLibrary})`)
	end

	if Options.PromiseLibrary then
		Imports.Push(`local Promise = require({Options.PromiseLibrary})`)
	end

	--> Replication
	local Replication = Builder.new()
	Return.Push("StepReplication = StepReplication,", 1, 1)

	if not Options.ManualReplication then
		if Context == "Server" then
			Replication.Push("RunService.Heartbeat:Connect(StepReplication)")
		elseif Context == "Client" then
			Replication.Push("local Elapsed = 0")
			local Connection = Blocks.Connection("RunService.Heartbeat", "DeltaTime: number")
				:Line("Elapsed += DeltaTime")
				:Compare("Elapsed", "(1 / 61)", "GreaterOrEquals")
					:Line("Elapsed -= (1 / 61)")
					:Line("StepReplication()")
				:End()
			:End()
			Replication.PushLines(Connection.Content)
		end
	end

	--> Parse declarations
	Generators.AbstractSyntaxTree(AbstractSyntaxTree.Value.Declarations)

	--> Generate context source
	local Source = Sources[Context]

	if Channels.Reliable.Listening then
		Reliables = Reliables:End()
	end

	if Channels.Unreliable.Listening then
		Unreliables = Unreliables:End()
	end

	Reliables = Reliables:End():End()
	Unreliables = Unreliables:End():End()

	local Globals = {}
	if not _G.BUNDLED then
		Globals = table.clone(DEBUG_GLOBALS)
		Globals[#Globals] = string.format(Globals[#Globals], string.lower(Context))
	end

	local MergedOutput = Table.Merge(
		DIRECTIVES,
		VERSION_HEADER,
		Globals,
		string.split(Source[1], "\r"),
		Imports.DumpLines(),
		string.split(Sources.Base, "\r"),
		Events.DumpLines(),
		LuauTypes.DumpLines(),
		{"\n"},
		UserTypes.DumpLines(),
		string.split(Source[2], "\r"),
		{"\n"},
		Replication.DumpLines(),
		{"\n"},
		Reliables.Content,
		{"\n"},
		Unreliables.Content,
		{`\nreturn \{\n`},
		Return.DumpLines(),
		{"\n}"}
	)

	return table.concat(MergedOutput)
end

function Generator.GenerateTypeDefinitions(FileContext: "Client" | "Server", AbstractSyntaxTree: Parser.Body): string
	local Value = AbstractSyntaxTree.Value

	Generator.Reset()
	Context = FileContext
	Options = Value.Options
	Generators.AbstractSyntaxTree(Value.Declarations)

	return LuauTypes.Dump() 
		.. `\nreturn true`
end

return Generator