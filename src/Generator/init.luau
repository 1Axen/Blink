--!native
--!optimize 2
--!strict

local Blocks = require("./Blocks")
local Parser = require("../Parser")
local Builder = require("../Modules/Builder")
local Prefabs = require("./Prefabs")

local Sources = {
	Base = require("../Templates/Base"),
	Client = string.split(require("../Templates/Client"), "-- SPLIT --"),
	Server = string.split(require("../Templates/Server"), "-- SPLIT --"),
}

local DIRECTIVES = "--!strict\n--!native\n--!optimize 2\n--!nolint LocalShadow\n--#selene: allow(shadowing)\n"
local VERSION_HEADER = `-- File generated by Blink v{_G.VERSION or "0.0.0"} (https://github.com/1Axen/Blink)\n-- This file is not meant to be edited\n\n`

local EVENT_BODY = [[RecieveCursor = 0
RecieveBuffer = Buffer
RecieveInstances = Instances
RecieveInstanceCursor = 0
local Size = buffer.len(RecieveBuffer)]]

local RELIABLE_BODY = {
	Header = "local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances",
	Body = [[Load(PlayersMap[Player])
local Position = Allocate(Size)
buffer.copy(SendBuffer, Position, Buffer, 0, Size)
table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
PlayersMap[Player] = Save()]]
}

local UNRELIABLE_BODY = [[local Buffer = buffer.create(SendCursor)
buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)]]

local DEBUUG_GLOBALS = [[local og_typeof = typeof
local typeof = function(a: any)
    if type(a) == "table" then 
        return a.__typeof or "table" 
    end
    return og_typeof(a)
end
local task = require("@lune/task")
local game = _G.%s.game
]]

type Type = Parser.TypeDeclaration | Parser.EnumDeclaration | Parser.MapDeclaration | Parser.StructDeclaration | Parser.TupleDeclaration | Parser.TypeReference

local Scope: string?
local Context: string;
local Events: Builder.Builder;
local UserTypes: Builder.Builder;
local LuauTypes: Builder.Builder;
local Reliables: Blocks.Block;
local Unreliables: Blocks.Block;
local Return: Builder.Builder;
local Options: Parser.Options;

local Generators = {}
local Declarations = {}

local Channels: { [string]: { Count: number, Listening: boolean } } = {
	Reliable = { Count = 0, Listening = false },
	Unreliable = { Count = 0, Listening = false },
}

local Types = Prefabs.Types
local Primitives = Prefabs.Primitives
local Structures = Prefabs.Structures

--> Utility functions

local function GetTypesPath(Identifier: string, Scope: string?, Write: boolean): string
	return `Types.{Scope and `{Scope}.` or ""}{Write and "Write" or "Read"}{Identifier}`
end

local function GetExportName(Identifier: string): string
	return `{Scope and `{Scope}_` or ""}{Identifier}`
end

local function GenerateEnumLiterals(Enums: { string }): string
	local Literal = ""
	for Index, EnumItem in Enums do
		Literal ..= `"{EnumItem}"{Index < #Enums and " | " or ""}`
	end
	return Literal
end

--> Declaration functions

function Declarations.Primitive(Declaration: Parser.TypeDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Primitive = Value.Primitive
    local Generator = Primitives[Primitive]
    Generator.Generate(Declaration, Variable, Read, Write)
end

function Declarations.Enum(Declaration: Parser.EnumDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	local Enums = Value.Enums
	local Literal = GenerateEnumLiterals(Enums)
	Literal = string.gsub(Literal, "|", "or")

	--> Read body
	Types.u8.Read(`local Index`, Read)
	Read = Read:Compare("Index", "0", "Equals")
		for Index, EnumItem in Enums do
			if Index > 1 then
				Read = Read:Branch("Conditional", "Index", `{Index - 1}`, "Equals")
			end

			Read:Line(`{Variable} = "{EnumItem}"`)
		end
	Read:Branch("Default")
		:Line(`error(\`Unexpected enum: \{Index\}\`)`)
	:End()

	--> Write body
	local Allocation = Write:Allocate(1)
		for Index, EnumItem in Enums do
			if Index == 1 then
				Write = Write:Compare(Variable, `"{EnumItem}"`, "Equals")
			else
				Write = Write:Branch("Conditional", Variable, `"{EnumItem}"`, "Equals")
			end

			Write:Line(`buffer.writeu8(SendBuffer, {Allocation}, {Index - 1})`)
		end
	Write:Branch("Default")
		:Line(`error(\`Unexpected enum: \{{Variable}\}, expectd one of {Literal}.\`)`)
	:End()
end

function Declarations.Map(Declaration: Parser.MapDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local MapValue = Declaration.Value
	local Key = MapValue.Key
	local Value = MapValue.Value

	local KeyType = Generators.LuauType(Key)
	local ValueType = Generators.LuauType(Value)

	Read:Line(`{Variable} = \{\}`)
	Write:Line("local Elements = 0")
	Write:Line("local Position = Allocate(2)")
	Types.u16.Read(`local Elements`, Read)

	local ReadLoop = Read:Loop("_ = 1", "Elements")
	local WriteLoop = Write:Iterator("Key", "Element", Variable)

	ReadLoop:Line(`local Key: {KeyType}, Element: {ValueType};`)
	WriteLoop:Line("Elements += 1")
	Generators.UserType(Key :: Type, ReadLoop, WriteLoop, "Key")
	Generators.UserType(Value :: Type, ReadLoop, WriteLoop, "Element")
	ReadLoop:Line(`{Variable}[Key] = Element`)

	WriteLoop:End()
	ReadLoop:End()

	Write:Line("buffer.writeu16(SendBuffer, Position, Elements)")
end

function Declarations.Struct(Declaration: Parser.StructDeclaration, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
	local Value = Declaration.Value
	Read:Line(`{Variable} = \{\} :: any`)

	for _, Field in Value.Fields do
		local FieldValue = Field.Value
		local Identifier = FieldValue.Identifier
		local FieldVariable = `{Variable}.{Identifier}`
		Generators.UserType(Field :: Type, Read, Write, FieldVariable)
	end
end

function Declarations.Tuple(Declaration: Parser.TupleDeclaration, Read: Blocks.Block, Write: Blocks.Block)
	for Index, Value in Declaration.Value.Values do
		local Variable = `Value{Index}`
		Generators.UserType(Value :: Type, Read, Write, Variable)
	end
end

function Declarations.Reference(Declaration: Parser.TypeReference, Read: Blocks.Block, Write: Blocks.Block, Variable: string)
    local Value = Declaration.Value
	local Array = Value.Array
	local Reference = Value.Reference
	local ReferenceScope = Value.Scope

	local ReadPath = GetTypesPath(Reference, ReferenceScope, false)
	local WritePath = GetTypesPath(Reference, ReferenceScope, true)

	local ReadVariable = (Array and "Item" or Variable)
	local WriteVariable = (Array and `{Variable}[Index]` or Variable)

	if Array then
		Read, Write = Structures.Array(Variable, Read, Write, Array)
	end

	Read:Line(`{Array and `local {ReadVariable}` or ReadVariable} = {ReadPath}()`)
	Write:Line(`{WritePath}({WriteVariable})`)

	if Array then
		Read:Line(`table.insert({Variable}, {ReadVariable})`)
		Read:End()
		Write:End()
	end
end

function Declarations.Event(Declaration: Parser.EventDeclaration)
	local Value = Declaration.Value

	local Identifier = `EVENT_{Value.Identifier}`
	local Reliability = Value.Type

	local IsReliable = (Reliability == "Reliable")
	local IsUnreliable = (Reliability == "Unreliable")

	local Block = IsUnreliable and Unreliables or Reliables
	local Channel = IsUnreliable and Channels.Unreliable or Channels.Reliable

	local Index = Channel.Count
	local Queue = `Queue.{Reliability}[{Index}]`
	local Connection = `Events.{Reliability}[{Index}]`

	--> Data body
	local _, Values, _, Arguments = Generators.LuauType(Value.Data, true)
	local Read, Write = Generators.Event(Value.Data :: Type, Index, Identifier)
	UserTypes.PushMultiline(Read, 1, 0, false)
	UserTypes.PushMultiline(Write, 1, 0, false)

	--> Return body
	local Body = Builder.new()
	local Indent = Scope and 2 or 1
	local WriteEvent = `{GetTypesPath(Identifier, Scope, true)}({Arguments})`
	Body.Push(`{Value.Identifier} = \{`, 1, Indent)

	if Value.From ~= Context then
		--> Create queue and event branch
		Events.Push(`{Queue} = table.create(256)`)
		Block = (Channel.Listening == false)
			and Block:Compare("Index", Index, "Equals")
			or Block:Branch("Conditional", "Index", Index, "Equals")
	
		--> Update event block to branch block
		if IsUnreliable then
			Unreliables = Block
		else
			Reliables = Block
		end
		
		--> Update channel status
		Channel.Listening = true

		--> Event recieve body
		local ListenerArguments = `{Context == "Server" and "Player, " or ""}{Arguments}`
		Block:Line(`local {Values} = {GetTypesPath(Identifier, Scope, false)}()`)
		Block:Compare(Connection, "nil", "Not")
			:Line(Value.Call == "SingleSync" and `{Connection}({ListenerArguments})` or `task.spawn({Connection}, {ListenerArguments})`)
		:Branch("Default")
			:Compare(`#{Queue}`, "256", "Greater")
				:Line(`warn("[Blink]: Event queue of \\"{Value.Identifier}\\" exceeded 256, did you forget to implement a listener?")`)
			:End()
			:Line(`table.insert({Queue}, \{{ListenerArguments}\} :: \{any\})`)
		:End()

		local ContextArguments = `Listener: ({Context == "Server" and "Player: Player, " or ""}{Values}) -> ()`
		local Disconnect = Blocks.Function("", "", "()")
			:Line(`{Queue} = \{\}`)
			:Line(`{Connection} = nil`)
		:End()

		local FlushQueue = Blocks.Function("", "", "()")
			:Line(`local EventQueue = {Queue} or \{\}`)
			:Line(`{Queue} = nil`)
			:Iterator("Index", "Arguments", "EventQueue")
				:Line(Value.Call == "SingleSync" and `Listener(table.unpack(Arguments))` or `task.spawn(Listener, table.unpack(Arguments))`)
			:End()
		:End()

		local Listener = Blocks.Function("On", ContextArguments, `() -> ()`, true)
			:Line(`{Connection} = Listener`)
			:Multiline(`task.spawn({FlushQueue:Unwrap()})`, 1)
			:Multiline(`return {Disconnect:Unwrap()}`, 1)
		:End()

		Body.PushMultiline(Listener:Unwrap(), 0, Indent + 1)
	elseif Context == "Client" then
		local Fire = Blocks.Function("Fire", Values, "()", true)
			if IsReliable then
				Fire:Line(WriteEvent)
			else
				Fire:Line(`local Previous = Save()`)
				Fire:Line(`Load()`)
				Fire:Line(WriteEvent)
				Fire:Line("local Buffer = buffer.create(SendCursor)")
				Fire:Line("buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)")
				Fire:Line("Unreliable:FireServer(Buffer, SendInstances)")
				Fire:Line("Load(Previous)")
			end
		Fire:End()
		Body.PushMultiline(Fire:Unwrap(), 0, Indent + 1)
	else
		local Fire = Blocks.Function("Fire", `Player: Player, {Values}`, "()", true)
			if IsReliable then
				Fire:Line("Load(PlayersMap[Player])")
				Fire:Line(WriteEvent)
				Fire:Line("PlayersMap[Player] = Save()")
			else
				Fire:Line("Load()")
				Fire:Line(WriteEvent)
				Fire:Multiline(UNRELIABLE_BODY, 1)
				Fire:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
			end
		Fire:End()

		local FireAll = Blocks.Function("FireAll", Values, "()", true)
			if IsReliable then
				FireAll:Line("Load()")
				FireAll:Line(WriteEvent)
				FireAll:Line(RELIABLE_BODY.Header)
				FireAll:Iterator("_", "Player", "Players:GetPlayers()")
					:Multiline(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireAll:Line("Load()")
				FireAll:Line(WriteEvent)
				FireAll:Multiline(UNRELIABLE_BODY, 1)
				FireAll:Line("Unreliable:FireAllClients(Buffer, SendInstances)")
			end
		FireAll:End()

		local FireList = Blocks.Function("FireList", `List: \{Player\}, {Values}`, "()", true)
			if IsReliable then
				FireList:Line("Load()")
				FireList:Line(WriteEvent)
				FireList:Line(RELIABLE_BODY.Header)
				FireList:Iterator("_", "Player", "List")
					:Multiline(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireList:Line("Load()")
				FireList:Line(WriteEvent)
				FireList:Multiline(UNRELIABLE_BODY, 1)
				FireList:Iterator("_", "Player", "List")
					:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
				:End()
			end
		FireList:End()

		local FireExcept = Blocks.Function("FireExcept", `Except: Player, {Values}`, "()", true)
			if IsReliable then
				FireExcept:Line("Load()")
				FireExcept:Line(WriteEvent)
				FireExcept:Line(RELIABLE_BODY.Header)
				FireExcept:Iterator("_", "Player", "Players:GetPlayers()")
					:Compare("Player", "Except", "Equals")
						:Line("continue")
					:End()
					:Multiline(RELIABLE_BODY.Body, 2)
				:End()
			else
				FireExcept:Line("Load()")
				FireExcept:Line(WriteEvent)
				FireExcept:Multiline(UNRELIABLE_BODY, 1)
				FireExcept:Iterator("_", "Player", "Players:GetPlayers()")
					:Compare("Player", "Except", "Equals")
						:Line("continue")
					:End()
					:Line("Unreliable:FireClient(Player, Buffer, SendInstances)")
				:End()
			end
		FireExcept:End()

		Body.PushMultiline(Fire:Unwrap() .. ",", 0, Indent + 1)
		Body.PushMultiline(FireAll:Unwrap() .. ",", 0, Indent + 1)
		Body.PushMultiline(FireList:Unwrap() .. ",", 0, Indent + 1)
		Body.PushMultiline(FireExcept:Unwrap() .. ",", 0, Indent + 1)
	end

	Channel.Count += 1

	Body.Push(`\},`, 1, Indent)
	Return.PushMultiline(Body.Dump(), 0)
end

function Declarations.Function(Declaration: Parser.FunctionDeclaration)
	local Value = Declaration.Value
	local DataIdentifier = `FUNCTION_DATA_{Value.Identifier}`
	local ReturnIdentifier = `FUNCTION_RETURN_{Value.Identifier}`

	local Yield = Value.Yield
	local IsFuture = (Yield == "Future")
	local IsPromise = (Yield == "Promise")
	local IsCoroutine = (Yield == "Coroutine")

	if IsFuture and not Options.FutureLibrary then
		error(`Cannot use yield type: "Future", without providing a path to the future library.`)
	end

	if IsPromise and not Options.PromiseLibrary then
		error(`Cannot use yield type: "Promise", without providing a path to the promise library.`)
	end

	local Block = Reliables
	local Channel = Channels.Reliable

	local Index = Channel.Count
	local Queue = `Queue.Reliable[{Index}]`
	local Connection = `Events.Reliable[{Index}]`

	--> Data and return body
	local DataTypes, DataValues, _, DataArguments = Generators.LuauType(Value.Data, true)
	local ReturnTypes, ReturnValues, _, ReturnArguments = Generators.LuauType(Value.Return, true)

	do
		local Read, Write = Generators.Event(Value.Data :: Type, Index, DataIdentifier, "Data")
		UserTypes.PushMultiline(Read, 1, 0, false)
		UserTypes.PushMultiline(Write, 1, 0, false)
	end

	do
		local Read, Write = Generators.Event(Value.Return :: Type, Index, ReturnIdentifier, "Return")
		UserTypes.PushMultiline(Read, 1, 0, false)
		UserTypes.PushMultiline(Write, 1, 0, false)
	end

	--> Main
	local Body = Builder.new()
	local Indent = Scope and 2 or 1
	Body.Push(`{Value.Identifier} = \{`, 1, Indent)

	--> Create queue and event branch
	Events.Push(`{Queue} = table.create(256)`)
	Block = (Channel.Listening == false)
		and Block:Compare("Index", Index, "Equals")
		or Block:Branch("Conditional", "Index", Index, "Equals")
	
	--> Update event block to branch block
	Reliables = Block

	if Context == "Server" then
		--> Data recieve body
		Types.u8.Read("local InvocationIdentifier", Block)
		Block:Line(`local {DataValues} = {GetTypesPath(DataIdentifier, Scope, false)}()`)
		:Compare(Connection, "nil", "Not")
			:Line(`{Connection}(Player, {DataArguments}, InvocationIdentifier)`)
		:Branch("Default")
			:Compare(`#{Queue}`, "256", "Greater")
				:Line(`warn("[Blink]: Event queue of \\"{Value.Identifier}\\" exceeded 256, did you forget to implement a listener?")`)
			:End()
			:Line(`table.insert({Queue}, \{Player, {DataArguments}, InvocationIdentifier\} :: \{any\})`)
		:End()

		--> Data listener body
		local FlushQueue = Blocks.Function("", "", "()")
			:Line(`local EventQueue = {Queue} or \{\}`)
			:Line(`{Queue} = nil`)
			:Iterator("Index", "Arguments", "EventQueue")
				:Line(`{Connection}(table.unpack(Arguments))`)
			:End()
		:End()

		local Serialize = Blocks.Function("", "")
			:Line(`local {ReturnValues} = Listener(Player, {DataArguments})`)
			:Line(`SerializationError = true`)
			:Line(`{GetTypesPath(ReturnIdentifier, Scope, true)}({ReturnArguments}, InvocationIdentifier)`)
		:End()

		local TrueListener = Blocks.Function(Connection, `Player: Player, {DataValues}, InvocationIdentifier: number`, "()", true)
			:Line("Load(PlayersMap[Player])")
			:Line("local SerializationError = false")
			:Multiline(`local Success, Error = pcall({Serialize:Unwrap()})`, 1)
			:Compare("Success", "true", "Not")
				:Compare("SerializationError", "true", "Equals")
					:Line(`error(\`Blink failed to serialize function: "{Value.Identifier}", \{Error\}\`)`)
				:End()
				:Line("local Position = Allocate(3)")
				:Line(`buffer.writeu8(SendBuffer, Position, {Index})`)
				:Line(`buffer.writeu8(SendBuffer, Position + 1, InvocationIdentifier)`)
				:Line(`buffer.writeu8(SendBuffer, Position + 2, 0)`)
				:Line(`warn(\`"{Value.Identifier}" encountered an error, \{Error\}\`)`)
			:End()
			:Line("PlayersMap[Player] = Save()")
		:End()

		local Listener = Blocks.Function("On", `Listener: (Player, {DataTypes}) -> ({ReturnTypes})`, "()", true)
			:Multiline(TrueListener:Unwrap(), 1)
			:Multiline(`task.spawn({FlushQueue:Unwrap()})`, 1)
		:End()

		Body.PushMultiline(Listener:Unwrap(), 0, 2)
	else
		--> Return recieve body
		local Deserialize = Blocks.Function("", "")
			:Return(`{GetTypesPath(ReturnIdentifier, Scope, false)}()`)
		:End()

		Types.u8.Read("local InvocationIdentifier", Block)
		Block:Compare("Calls[InvocationIdentifier]", "nil", "Not")
			:Multiline(`local Success, {ReturnArguments} = pcall({Deserialize:Unwrap()})`, Block.Indent + 1)
			:Line(`task.spawn(Calls[InvocationIdentifier], Success, {ReturnArguments})`)
		:End()

		--> Function listener body
		local Error = `"Server encountered an exception while processing \\"{Value.Identifier}\\"."`
		local Contents = Blocks.Block()
			:Line("local InvocationIdentifier = Invoke()")
			:Line(`{GetTypesPath(DataIdentifier, Scope, true)}({DataArguments}, InvocationIdentifier)`)
			:Line("Calls[InvocationIdentifier] = coroutine.running()")
			:Line(`local Success, {ReturnValues} = coroutine.yield()`)
			:Compare("Success", "true", "Not")
				:Line(`error({Error})`)
			:End()
			:Return(ReturnArguments)
		:Unwrap()

		local Invoke;
		if IsFuture then
			local Wrapper = Blocks.Function("", "")
				:Multiline(Contents)
			:End()

			Invoke = Blocks.Function("Invoke", DataValues, `Future.Future<{ReturnTypes}>`, true)
			Invoke:Multiline(`return Future.Try({Wrapper:Unwrap()})`, 1)
		elseif IsPromise then
			local OnCancel = Blocks.Function("", "")
				:Line("Calls[InvocationIdentifier] = nil")
			:End()

			local Promise = Blocks.Function("", "Resolve, Reject, OnCancel")
				:Line("local InvocationIdentifier = Invoke()")
				:Line(`{GetTypesPath(DataIdentifier, Scope, true)}({DataArguments}, InvocationIdentifier)`)
				:Line("Calls[InvocationIdentifier] = coroutine.running()")
				:Multiline(`OnCancel({OnCancel:Unwrap()})`, 1)
				:Line(`local Success, {ReturnValues} = coroutine.yield()`)
				:Compare("Success", "true", "Not")
					:Line(`Reject({Error})`)
					:Return("")
				:End()
				:Line(`Resolve({ReturnArguments})`)
			:End()

			Invoke = Blocks.Function("Invoke", DataValues, `unknown`, true)
			Invoke:Multiline(`return Promise.new({Promise:Unwrap()})`, 1)
		else
			Invoke = Blocks.Function("Invoke", DataValues, `({ReturnTypes})`, true)
			Invoke:Multiline(Contents, 1)
		end

		Body.PushMultiline(Invoke:End():Unwrap(), 0, 2)
	end

	Channel.Count += 1
	Channel.Listening = true

	Body.Push(`\},`, 1, Indent)
	Return.PushMultiline(Body.Dump(), 0)
end

--> Generator functions
function Generators.Optional(Declaration: Type, Read: Blocks.Block, Write: Blocks.Block, Variable: string): (Blocks.Block, Blocks.Block)
	if Declaration.Type == "TypeDeclaration" and Declaration.Value.Primitive == "Instance" then
		Read = Read:Compare("typeof(RecieveInstances[RecieveInstanceCursor])", "\"Instance\"", "Equals")
	else
		Types.u8.Write(`{Variable} ~= nil and 1 or 0`, Write)
		Read = Read:Compare(`buffer.readu8(RecieveBuffer, {Read:Read(1)})`, "1", "Equals")
		Write = Write:Compare(Variable, "nil", "Not")
	end

	return Read, Write
end

function Generators.UserType(Declaration: Type, Read: Blocks.Block, Write: Blocks.Block, Variable: string?)
	local Value = Declaration.Value
	local Optional = Value.Optional
	local Variable = Variable or "Value"
	local IsInstance = (Declaration.Type == "TypeDeclaration" and ((Value :: any).Primitive :: string) == "Instance")

	if not _G.BUNDLED then
		Read:Comment(`{Variable}: {Value.Identifier}`)
		Write:Comment(`{Variable}: {Value.Identifier}`)
	end

	if IsInstance then
		Read:Line("RecieveInstanceCursor += 1")
	end

	if Optional then
		Read, Write = Generators.Optional(Declaration, Read, Write, Variable)
	end

	if Declaration.Type == "TypeDeclaration" then
        Declarations.Primitive(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "EnumDeclaration" then
		Declarations.Enum(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "MapDeclaration" then
		Declarations.Map(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "StructDeclaration" then
		Declarations.Struct(Declaration, Read, Write, Variable)
	elseif Declaration.Type == "TupleDeclaration" then
		Declarations.Tuple(Declaration, Read, Write)
	elseif Declaration.Type == "TypeReference" then
		Declarations.Reference(Declaration, Read, Write, Variable)
    end

	if Optional then
		Read:End()
		if not IsInstance then
			Write:End()
		end
	end
end

function Generators.LuauType(Declaration: Parser.Declaration, UseTypeAsValue: boolean?): (string, string, string, string)
	local Type = ""
	local Values = ""
	local Export = GetExportName(Declaration.Value.Identifier)
	local Returns = "Value"

	if Declaration.Type == "TypeDeclaration" then
		local Value = (Declaration :: Parser.TypeDeclaration).Value
		local Primitive = Primitives[Value.Primitive]
		if type(Primitive.Type) == "function" then
			Type = Primitive.Type(Declaration :: Parser.TypeDeclaration)
		else
			Type = Primitive.Type
		end

		if Value.Array then
			Type = `\{{Type}\}`
		end
	elseif Declaration.Type == "EnumDeclaration" then
		local Value = (Declaration :: Parser.EnumDeclaration).Value
		Type = GenerateEnumLiterals(Value.Enums)
	elseif Declaration.Type == "MapDeclaration" then
		local MapValue = (Declaration :: Parser.MapDeclaration).Value
		local Key = Generators.LuauType(MapValue.Key)
		local Value = Generators.LuauType(MapValue.Value)
		Type = `\{[{Key}]: {Value}\}`
	elseif Declaration.Type == "StructDeclaration" then
		local Value = Declaration.Value
		Type = "{ "

		for _, Field in Value.Fields do
			local FieldValue = Field.Value
			local Identifier = FieldValue.Identifier
			local FieldType = Generators.LuauType(Field)
			Type ..= `{Identifier}: {FieldType}, `
		end

		Type ..= " }"
	elseif Declaration.Type == "TypeReference" then
		local Value = (Declaration :: Parser.TypeReference).Value
		local Reference = Value.Reference
		local ReferenceScope = Value.Scope
		local Prefix = ReferenceScope and `{ReferenceScope}_` or ""
		
		Type = `{Prefix}{Reference}` 

		if Value.Array then
			Type = `\{{Type}\}`
		end
	elseif Declaration.Type == "TupleDeclaration" then
		local Value = (Declaration :: Parser.TupleDeclaration).Value
		local TupleValues = Value.Values
		Returns = ""

		for Index, TupleValue in TupleValues do
			local Variable = `Value{Index}`
			local ValueType = Generators.LuauType(TupleValue)
			local Seperator = Index < #TupleValues and ", " or ""
			Type ..= `{ValueType}{Seperator}`
			Values ..= `{Variable}: {ValueType}{Seperator}`
			Returns ..= `{Variable}{Seperator}`
		end
	end

	--> Generalized type generation, works for everything except tuples
	if Declaration.Type ~= "TupleDeclaration" then
		if Declaration.Value.Optional then
			Type = `({Type})?`
		end

		Values = `Value: {UseTypeAsValue and Type or Export}`
	end

	return Type, Values, Export, Returns
end

function Generators.Type(Declaration: Type): (string, string, string)
	local Value = Declaration.Value
	local Identifier = Value.Identifier

	local Type, Values, Export, Returns = Generators.LuauType(Declaration)
	local Read = Blocks.Function(GetTypesPath(Identifier, Scope, false), "", `({Export})`)
	local Write = Blocks.Function(GetTypesPath(Identifier, Scope, true), Values, "()")

	Read:Line(`local {Values};`)
	Generators.UserType(Declaration, Read, Write)

	return `export type {Export} = {Type}`, Read:Return(Returns):End():Unwrap(), Write:End():Unwrap()
end

function Generators.Event(Data: Type, Index: number, Identifier: string, Function: ("Data" | "Return")?): (string, string)
	local Type, Values, _, Returns = Generators.LuauType(Data, true)

	local Arguments = `{Values}{Function and ", InvocationIdentifier: number" or ""}`
	local Read = Blocks.Function(GetTypesPath(Identifier, Scope, false), "", `({Type})`)
	local Write = Blocks.Function(GetTypesPath(Identifier, Scope, true), Arguments, "()")

	if not _G.BUNDLED then
		Write:Comment(`{Identifier} ({Index})`)
	end

	Types.u8.Write(Index, Write)
	if Function then
		Types.u8.Write("InvocationIdentifier", Write)
		if Function == "Return" then
			Types.u8.Write("1", Write)
			Types.u8.Read("local Success", Read)
			Read:Compare("Success", "1", "Not")
				:Line("error(\"Server encountered an error.\")")
			:End()
		end
	end

	Read:Line(`local {Values};`)
	Generators.UserType(Data, Read, Write)

	return Read:Return(Returns):End():Unwrap(), Write:End():Unwrap()
end

function Generators.Scope(Declaration: Parser.ScopeDeclaration)
	local Value = Declaration.Value
	local Identifier = Value.Identifier

	Scope = Identifier
	Return.Push(`{Identifier} = \{`, 1, 1)
	UserTypes.PushFront(`Types.{Identifier} = \{\}`, 2)
	Generators.AbstractSyntaxTree(Value.Declarations)
	Return.Push(`},`, 1, 1)
	Scope = nil
end

function Generators.AbstractSyntaxTree(Value: { Parser.Declaration })
	for Index, Declaration in Value do
		if
			Declaration.Type == "TypeDeclaration"
			or Declaration.Type == "EnumDeclaration"
			or Declaration.Type == "StructDeclaration"
			or Declaration.Type == "MapDeclaration"
		then
			local Export, Read, Write = Generators.Type(Declaration :: Type)
			UserTypes.PushMultiline(Read, 1, 0, false)
			UserTypes.PushMultiline(Write, 1, 0, false)
			LuauTypes.PushMultiline(Export, 0, 0, false)
		elseif Declaration.Type == "ScopeDeclaration" then
			Generators.Scope(Declaration :: Parser.ScopeDeclaration)
		elseif Declaration.Type == "EventDeclaration" then
			Declarations.Event(Declaration :: Parser.EventDeclaration)
		elseif Declaration.Type == "FunctionDeclaration" then
			Declarations.Function(Declaration :: Parser.FunctionDeclaration)
		end
	end
end

local Generator = {}

function Generator.Reset()
	--> Setup new builders
	Events = Builder.new()
    UserTypes = Builder.new()
    LuauTypes = Builder.new()
	Return = Builder.new()

	--> Reset channels
	Channels.Reliable.Count = 0
	Channels.Unreliable.Count = 0
	Channels.Reliable.Listening = false
	Channels.Unreliable.Listening = false
end

function Generator.Generate(FileContext: "Client" | "Server", AbstractSyntaxTree: Parser.Body, UserOptions: Parser.Options): string
    local Imports = Builder.new()
	
	Generator.Reset()
	Context = FileContext
	Options = UserOptions

	--> Setup remote events
	local Signal = Context == "Client" and "OnClientEvent" or "OnServerEvent"
	local Arguments = (Context == "Server" and "Player: Player, " or "") .. "Buffer: buffer, Instances: {Instance}"

	Reliables = Blocks.Connection(`Reliable.{Signal}`, Arguments)
	Unreliables = Blocks.Connection(`Unreliable.{Signal}`, Arguments)

	Reliables:Multiline(EVENT_BODY, 1)
	Unreliables:Multiline(EVENT_BODY, 1)

	Reliables = Reliables:While("RecieveCursor < Size")
	Unreliables = Unreliables:While("RecieveCursor < Size")
	Types.u8.Read("local Index", Reliables)
	Types.u8.Read("local Index", Unreliables)

	--> Import async libraries
	if UserOptions.FutureLibrary then
		Imports.Push(`local Future = require({UserOptions.FutureLibrary})`)
	end

	if UserOptions.PromiseLibrary then
		Imports.Push(`local Promise = require({UserOptions.PromiseLibrary})`)
	end

	--> Replication
	local Replication = Builder.new()
	Return.Push("StepReplication = StepReplication,", 1, 1)

	if not UserOptions.ManualReplication then
		if Context == "Server" then
			Replication.Push("RunService.Heartbeat:Connect(StepReplication)")
		elseif Context == "Client" then
			Replication.Push("local Elapsed = 0")
			local Connection = Blocks.Connection("RunService.Heartbeat", "DeltaTime: number")
				:Line("Elapsed += DeltaTime")
				:Compare("Elapsed", "(1 / 61)", "GreaterOrEquals")
					:Line("Elapsed -= (1 / 61)")
					:Line("StepReplication()")
				:End()
			:End():Unwrap()
			Replication.PushMultiline(Connection)
		end
	end

	--> Parse declarations
	Generators.AbstractSyntaxTree(AbstractSyntaxTree.Value)

	--> Generate context source
	local Source = Sources[Context]

	if Channels.Reliable.Listening then
		Reliables = Reliables:End()
	end

	if Channels.Unreliable.Listening then
		Unreliables = Unreliables:End()
	end

	Reliables = Reliables:End():End()
	Unreliables = Unreliables:End():End()

	return DIRECTIVES
		.. VERSION_HEADER
		.. (if not _G.BUNDLED then string.format(DEBUUG_GLOBALS, string.lower(Context), string.lower(Context)) else "")
        .. Source[1]
		.. Imports.Dump()
		.. Sources.Base
		.. Events.Dump() .. "\n"
		.. LuauTypes.Dump() .. "\n"
		.. UserTypes.Dump()
		.. Source[2] .. "\n"
		.. Replication.Dump() .. "\n"
		.. Reliables:Unwrap() .. "\n\n"
		.. Unreliables:Unwrap() .. "\n"
		.. `\nreturn \{\n{Return.Dump()}\}`
end

function Generator.GenerateTypeDefinitions(FileContext: "Client" | "Server", AbstractSyntaxTree: Parser.Body, UserOptions: Parser.Options): string
	Generator.Reset()
	Context = FileContext
	Options = UserOptions

	--> Parse declarations
	Generators.AbstractSyntaxTree(AbstractSyntaxTree.Value)

	return LuauTypes.Dump() 
		.. `\nreturn true`
end

return Generator